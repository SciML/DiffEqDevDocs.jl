<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Notes on Algorithms · SciML Developer Documentation</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-90474609-3"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-90474609-3', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://docs.sciml.ai/DiffEqDevDocs/stable/internals/notes_on_algorithms/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="SciML Developer Documentation logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">SciML Developer Documentation</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Contributor Guide</span><ul><li><a class="tocitem" href="../../contributing/ecosystem_overview/">Ecosystem Overview</a></li><li><a class="tocitem" href="../../contributing/adding_packages/">Adding a new package to the common interface</a></li><li><a class="tocitem" href="../../contributing/adding_algorithms/">Adding Algorithms</a></li><li><a class="tocitem" href="../../contributing/defining_problems/">Developing A New Problem</a></li><li><a class="tocitem" href="../../contributing/diffeq_internals/">The DiffEq Internals</a></li><li><a class="tocitem" href="../../contributing/type_traits/">Type Traits</a></li></ul></li><li><span class="tocitem">Algorithm Development Tools</span><ul><li><a class="tocitem" href="../../alg_dev/test_problems/">Test Problems</a></li><li><a class="tocitem" href="../../alg_dev/convergence/">Convergence Simulations</a></li><li><a class="tocitem" href="../../alg_dev/benchmarks/">Benchmark Suite</a></li></ul></li><li><span class="tocitem">Internal Documentation</span><ul><li class="is-active"><a class="tocitem" href>Notes on Algorithms</a><ul class="internal"><li><a class="tocitem" href="#Explicit-Runge-Kutta-ODE-Algorithms"><span>Explicit Runge-Kutta ODE Algorithms</span></a></li></ul></li><li><a class="tocitem" href="../tableaus/">ODE Tableaus</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Internal Documentation</a></li><li class="is-active"><a href>Notes on Algorithms</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Notes on Algorithms</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SciML/DiffEqDevDocs.jl/blob/master/docs/src/internals/notes_on_algorithms.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Notes-on-Algorithms"><a class="docs-heading-anchor" href="#Notes-on-Algorithms">Notes on Algorithms</a><a id="Notes-on-Algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#Notes-on-Algorithms" title="Permalink"></a></h1><p>This page is a supplemental page which details some facts about the chosen algorithms, why some I took the time to make optimized versions for, and for others why they were ignored.</p><h2 id="Explicit-Runge-Kutta-ODE-Algorithms"><a class="docs-heading-anchor" href="#Explicit-Runge-Kutta-ODE-Algorithms">Explicit Runge-Kutta ODE Algorithms</a><a id="Explicit-Runge-Kutta-ODE-Algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#Explicit-Runge-Kutta-ODE-Algorithms" title="Permalink"></a></h2><p>From what I can tell, this is by far the most comprehensive comparison of Explicit Runge-Kutta ODE algorithms that you&#39;ll find.</p><h3 id="Implementations"><a class="docs-heading-anchor" href="#Implementations">Implementations</a><a id="Implementations-1"></a><a class="docs-heading-anchor-permalink" href="#Implementations" title="Permalink"></a></h3><p>The different implementations have been benchmarked against each other. The efficiency was calculated by weighing both the time and error on classic test problems. To make clear distinctions, solver options were tweaked to many different settings, including:</p><ul><li>Matching errors</li><li>Matching runtimes</li><li>Matching settings</li><li>Low/High tolerance</li></ul><p>The DifferentialEquations.jl implementations of the explicit Runge-Kutta solvers are by a good margin the most efficient implementations of the given algorithms. They utilize many extra tricks, nice caching, and threading if available, to vastly outperform the other methods in terms of efficiency (even with threading disabled). <code>:DP5</code> performs much better than <code>:dopri5</code>, which vastly outperform <code>ode45</code> (whose stepsize algorithm tends to have issues on some quasi-stiff problems). <code>:DP8</code> performs better than <code>dop853</code> in some cases, worse in others. Both vastly outperform <code>ode78</code>.</p><p>For this reason, the DifferentialEquations.jl non-stiff algorithms are the recommended implementations. ODEInterface non-stiff algorithms are only recommended for historical purposes (i.e. to match previous results) or to try <code>dop853</code> on a problem (work is being to find out what the difference is and squash the competition here!). The ODE.jl algorithms are not recommended for any serious use (the package is essentially deprecated: it&#39;s slow, gets high error, the timestepping algorithm is not robust, and doesn&#39;t implement many methods).</p><h3 id="Order-4"><a class="docs-heading-anchor" href="#Order-4">Order 4-</a><a id="Order-4-1"></a><a class="docs-heading-anchor-permalink" href="#Order-4" title="Permalink"></a></h3><p>At this stage, coefficient of the truncation error seems to win out, or you are willing to live with low tolerance anyways. Thus Bogacki-Shampine is the clear winner in this category because at order 2/3 with FASL it has minimal numbers of function evaluations but also is stable enough to step as needed. All other methods don&#39;t compare because of the FASL property boosting the order and thus the stability (for low orders, it pretty much holds that higher order = higher stability (for optimal number of steps), which is not true as we go higher), making it more stable and have less error for lower numbers of function evaluations than the others in this category.</p><h3 id="Order-5"><a class="docs-heading-anchor" href="#Order-5">Order 5</a><a id="Order-5-1"></a><a class="docs-heading-anchor-permalink" href="#Order-5" title="Permalink"></a></h3><p>[Note that for all of these Peter Stone&#39;s modifications do not seem to be helpful since, although they lower the truncation error, they also modify the stability region in ways that can be worrisome (mostly they shrink the stability in the complex axis near the origin, making the problems not as suitable for a &quot;general purpose default&quot; like one would hope with a 4/5 solver)]</p><p>The &quot;clear choice&quot; is the Dormand-Prince 4/5 pair. This is the pair which is used by default as ode45 in MATLAB, and serves similar functions in scipy, ODE.jl, etc. The golden standard implementation is Hairer&#39;s DOPRI5 (offered by ODEInterface.jl). After optimizations, DifferentialEquations.jl&#39;s native DP5 solver is much more efficient (between 4x-400x) than DOPRI5&#39;s, with various design choices factoring into this (which are documented in the benchmarks). This is pre-threading, and within method threading will likely be at least doubled or tripled when threading is enabled. Thus it&#39;s clear that the reference implementation to try other methods against is the DifferentialEquations.jl DP5 method.</p><p>It&#39;s obvious that anything before Dormand-Prince 4/5&#39;s pair is simply not as good because of the optimizations on the local truncation error coefficient and the fact that FASL schemes essentially have one less function evaluation. So the previous algorithms were implemented as tableaus for the historical reasons but dealt with no further. These methods include the Runge, Cassity, Butcher, Fehlburg, Lawson, Luther and Konen, and Kutta schemes.</p><p>The next set of schemes are the Papakostas-Papageorgiou schemes. The problem is that they don&#39;t really get the much lower on the error than DP5, but also have wacky stability near the origin.</p><p>Tsitouras&#39;s looks to be a good match against DP5 as a 6-stage scheme to take on DP5. Its stability is similar to DP5 but its first error term is an order of magnitude smaller. More tests will likely determine that this is much better than DP5 in accordance with his paper.</p><p>Lastly, there are the 7-stage schemes. The more recent one is due to Sharp and Smart, but I am ignoring this because its error term is almost an order of magnitude larger than the BS pair, and its stability region is wonky near the origin. Its only plus over the BS pair is that it has a slightly larger stability in the real axis, which is not important when paired with adaptive stepping and for use on non-stiff problems.</p><p>That leaves us with the Bogacki-Shampine pair. This pair gets more than an order of magnitude lower truncation error, enhanced complex stability, and two error estimators to make it more robust. In fact, this is the default which is chosen in Mathematica. Its downside is that since it is an 8-stage scheme, it requires an additional function evaluation.</p><p>Further tests will likely narrow this down to Tsitouras vs Bogacki-Shampine. Who will come out on top? Who knows.</p><h3 id="Order-6"><a class="docs-heading-anchor" href="#Order-6">Order 6</a><a id="Order-6-1"></a><a class="docs-heading-anchor-permalink" href="#Order-6" title="Permalink"></a></h3><p>Sharp-Verner has bad complex stability near the origin. I don&#39;t like any of the Peter Stone modifications here. Butcher and Chummund methods have stability issues near the origin as well. Huta&#39;s method has too high of an error coefficient. Verner&#39;s 1991 has bad complex stability. Same as the most robust. The Verner &quot;most efficient&quot; has really good stability and error coefficient. In fact, nothing is even close except for Tsitouras&#39; method. The DP method is two orders of magnitude higher in error coefficient than Verner. The Luther methods have too much error. Same as Tsitouras-Papakostas and  M. Tanaka, K. Kasuga, S. Yamashita and H. Yazaki.</p><p>Without a doubt the winner is the Verner &quot;most efficient&quot;.</p><h3 id="Order-7"><a class="docs-heading-anchor" href="#Order-7">Order 7</a><a id="Order-7-1"></a><a class="docs-heading-anchor-permalink" href="#Order-7" title="Permalink"></a></h3><p>The Enright-Verner and other Verner methods all have stability issues near the origin in the complex plane and higher error coefficients. Sharp and Smart have higher error coefficients. Peter Stone&#39;s methods all have higher error. It&#39;s very clear that the best here is the Tanaka-Yamashita (efficient, not the stable) method by far.</p><h3 id="Order-8"><a class="docs-heading-anchor" href="#Order-8">Order 8</a><a id="Order-8-1"></a><a class="docs-heading-anchor-permalink" href="#Order-8" title="Permalink"></a></h3><p>The Cooper-Verner methods do not have an error estimate and so no adaptive timestepping can be done. This is a deal-breaker. Going into this one would think that the clear winner would be Dormand-Prince 8. But that&#39;s not the case. However, that&#39;s comparing the classical 1981 DP87. Notice that the code for Dop853 is based off of the 1989 paper which has different coefficients (and currently I have no analysis for this).</p><p>The other methods include Verner&#39;s Maple dverk78 which is bested in both stability and error coefficient by Enright-Verner which is bested by Tsitouras-Papakostas.</p><p>Thus the final showdown is between DP853 vs the Tsitouras-Papakostas pair.</p><h3 id="Order-9"><a class="docs-heading-anchor" href="#Order-9">Order 9</a><a id="Order-9-1"></a><a class="docs-heading-anchor-permalink" href="#Order-9" title="Permalink"></a></h3><p>The Tsitouras scheme and the Sharp scheme have funky stability near the origin. Verner&#39;s schemes are much safer, and with similar error. They clearly dominate this category.</p><h3 id="Order-10"><a class="docs-heading-anchor" href="#Order-10">Order 10</a><a id="Order-10-1"></a><a class="docs-heading-anchor-permalink" href="#Order-10" title="Permalink"></a></h3><p>Curtis&#39; scheme has more function evaluations than needed, and Peter Stone&#39;s modification reduces the truncation error by a lot but adds three more function evaluations. Thus Hairer&#39;s 17 stage scheme (whose error and stability is similar to Curtis&#39;) is clearly better. Once again Peter Stone&#39;s modification adds three steps but does not reduce the truncation error here, so the unmodified version does better.</p><p>Tom Baker&#39;s method increases the stability region to something which is more than necessary but adds 4 function evaluations to do so (without lowering the error very much). Ono&#39;s scheme minimizes the error more than Hairer&#39;s here, with all else being basically the same. The Peter Stone methods add a lot of function evaluations (5+) and so they would only be useful in the case where the function evaluations are quick yet you still want really small error. Even then I&#39;m not convinced they are better than the other methods, or better than the higher order methods which use less steps. The stability is only okay.</p><p>The Feagin scheme is fine, but with more error and less stability than the Hairer scheme. Thus it seems clear that Hairer&#39;s method dominates this category. However, that&#39;s only because it does not include an error estimate. Feagin&#39;s scheme is close in error and stability, but includes an error estimate which can be used for adaptivity, making it the choice in this category.</p><h3 id="Order-11"><a class="docs-heading-anchor" href="#Order-11">Order 11</a><a id="Order-11-1"></a><a class="docs-heading-anchor-permalink" href="#Order-11" title="Permalink"></a></h3><p>The order 11 schemes are due to Tom Baker at the University of Teeside. They have a nice sparsity pattern and receive slightly lower truncation error coefficents than the Feagin, but Feagin&#39;s dominates by being &quot;almost order 13&quot; anyways so while a nice try the order 11 scheme is likely overwhelmed in any case where it would be useful.</p><h3 id="Order-12"><a class="docs-heading-anchor" href="#Order-12">Order 12</a><a id="Order-12-1"></a><a class="docs-heading-anchor-permalink" href="#Order-12" title="Permalink"></a></h3><p>Here there are the Feagin schemes and Ono&#39;s scheme. Ono&#39;s scheme gets horrible stability with more error and so it&#39;s not in the running. Peter Stone&#39;s modifications do not make a substantive change, and where they do they get rid of the nice property that the Feagin 12 method satisfies many of the higher order conditions as well, making it look even higher order on some problems. Thus the standard Feagin 12 seems to win out in this category.</p><h3 id="Order-14"><a class="docs-heading-anchor" href="#Order-14">Order 14</a><a id="Order-14-1"></a><a class="docs-heading-anchor-permalink" href="#Order-14" title="Permalink"></a></h3><p>In this category there is just the Feagin. Peter Stone&#39;s modification barely changes anything in the analysis so I did not even attempt it.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../alg_dev/benchmarks/">« Benchmark Suite</a><a class="docs-footer-nextpage" href="../tableaus/">ODE Tableaus »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Sunday 27 November 2022 00:34">Sunday 27 November 2022</span>. Using Julia version 1.8.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

var documenterSearchIndex = {"docs":
[{"location":"contributing/diffeq_internals/#The-DiffEq-Internals","page":"The DiffEq Internals","title":"The DiffEq Internals","text":"","category":"section"},{"location":"contributing/diffeq_internals/","page":"The DiffEq Internals","title":"The DiffEq Internals","text":"The DiffEq solvers, OrdinaryDiffEq, StochasticDiffEq, FiniteElementDiffEq, etc. all follow a similar scheme which leads to rapid development and high performance. This portion of the documentation explains how the algorithms are written.","category":"page"},{"location":"contributing/diffeq_internals/#Developing-New-Solver-Algorithms","page":"The DiffEq Internals","title":"Developing New Solver Algorithms","text":"","category":"section"},{"location":"contributing/diffeq_internals/","page":"The DiffEq Internals","title":"The DiffEq Internals","text":"The easiest way to get started would be to add new solver algorithms. This is a pretty simple task as there are tools which put you right into the \"hot loop\". For example, take a look at the ODE solver code. The mode solve(::ODEProblem,::OrdinaryDiffEqAlgorithm) is glue code to a bunch of solver algorithms. The algorithms which are coded in DifferentialEquations.jl can be found in src/integrators.jl. The actual step is denoted by the perform_step!(integrator) function. For example, take a look at the Midpoint method's implementation:","category":"page"},{"location":"contributing/diffeq_internals/","page":"The DiffEq Internals","title":"The DiffEq Internals","text":"@inline function perform_step!(integrator,cache::MidpointConstantCache,f=integrator.f)\n  @unpack t,dt,uprev,u,k = integrator\n  halfdt = dt/2\n  k = integrator.fsalfirst\n  k = f(t+halfdt,uprev+halfdt*k)\n  u = uprev + dt*k\n  integrator.fsallast = f(u,p,t+dt) # For interpolation, then FSAL'd\n  integrator.k[1] = integrator.fsalfirst\n  integrator.k[2] = integrator.fsallast\n  @pack integrator = t,dt,u\nend","category":"page"},{"location":"contributing/diffeq_internals/","page":"The DiffEq Internals","title":"The DiffEq Internals","text":"The available items are all unloaded from the integrator in the first line. fsalfirst inherits the value of fsallast on the last line. The algorithm is written in this form so that way the derivative of both endpoints is defined, allowing the vector integrator.k to determine a  Hermite interpolation polynomial (in general, the k values for each algorithm form the interpolating polynomial). Other than that, the algorithm is as basic as it gets for the Midpoint method, making sure to set fsallast at the last line. The results are then packaged back into the integrator to mutate the state.","category":"page"},{"location":"contributing/diffeq_internals/","page":"The DiffEq Internals","title":"The DiffEq Internals","text":"Note the name ConstantCache. In OrdinaryDiffEq.jl, the Algorithm types are used for holding type information about which solver to choose, and its the \"cache\" types which then hold the internal caches and state. ConstantCache types are for non in-place calculations f(u,p,t) and Cache types (like MidpointCache) include all of the internal arrays. Their constructor is specified in the cache.jl file. The cache (and the first fsalfirst) is initialized in the initialize! function next to the cache's perform_step! function.","category":"page"},{"location":"contributing/diffeq_internals/","page":"The DiffEq Internals","title":"The DiffEq Internals","text":"The main inner loop can be summarized by the solve! command:","category":"page"},{"location":"contributing/diffeq_internals/","page":"The DiffEq Internals","title":"The DiffEq Internals","text":"@inbounds while !isempty(integrator.opts.tstops)\n   while integrator.tdir*integrator.t < integrator.tdir*top(integrator.opts.tstops)\n     loopheader!(integrator)\n     @ode_exit_conditions\n     perform_step!(integrator,integrator.cache)\n     loopfooter!(integrator)\n     if isempty(integrator.opts.tstops)\n       break\n     end\n   end\n   handle_tstop!(integrator)\n end\n postamble!(integrator)","category":"page"},{"location":"contributing/diffeq_internals/","page":"The DiffEq Internals","title":"The DiffEq Internals","text":"The algorithm runs until tstop is empty. It hits the loopheader! in order to accept/reject the previous step and choose a new dt. This is done at the top so that way the iterator interface happens \"mid-step\" instead of \"post-step\". In here the algorithm is also chosen for the switching algorithms.","category":"page"},{"location":"contributing/diffeq_internals/","page":"The DiffEq Internals","title":"The DiffEq Internals","text":"Then the perform_step! is called. (The exit conditions throw an error if necessary.) Afterwards, the loopfooter! is used to calculate new timesteps, save, and apply the callbacks. If a value of tstops is hit, the algorithm breaks out of the inner-most loop to save the value.","category":"page"},{"location":"contributing/diffeq_internals/","page":"The DiffEq Internals","title":"The DiffEq Internals","text":"Adding algorithms to the other problems is very similar, just in a different package.","category":"page"},{"location":"contributing/diffeq_internals/#Extras","page":"The DiffEq Internals","title":"Extras","text":"","category":"section"},{"location":"contributing/diffeq_internals/","page":"The DiffEq Internals","title":"The DiffEq Internals","text":"If the method is a FSAL method then it needs to be set via isfsal and fsalfirst should be defined before the loop, with fsallast what's pushed up to fsalfirst upon a successful step. See :DP5 for an example.","category":"page"},{"location":"contributing/diffeq_internals/","page":"The DiffEq Internals","title":"The DiffEq Internals","text":"If tests fail due to units (i.e. Unitful), don't worry. I would be willing to fix that up. To do so, you have to make sure you keep separate your rateTypes and your uTypes since the rates from f will have units of u but divided by a unit of time. If you simply try to write these into u, the units part will fail (normally you have to multiply by a dt).","category":"page"},{"location":"contributing/diffeq_internals/","page":"The DiffEq Internals","title":"The DiffEq Internals","text":"If you want to access the value of u at the second-last time point, you can use uprev2 value. But in order to copy uprev value to uprev2 after each timestep, you need to make alg_extrapolates(alg::Your_Alg) = true in the alg_utils.jl file.","category":"page"},{"location":"contributing/defining_problems/#Developing-A-New-Problem","page":"Developing A New Problem","title":"Developing A New Problem","text":"","category":"section"},{"location":"contributing/defining_problems/","page":"Developing A New Problem","title":"Developing A New Problem","text":"New problems should be defined for new types of differential equations, new partial differential equations, and special subclasses of differential equations for which solvers can dispatch on for better performance.","category":"page"},{"location":"contributing/defining_problems/","page":"Developing A New Problem","title":"Developing A New Problem","text":"To develop a new problem, you need to make a new DEProblem and a new DESolution. These types belong in DiffEqBase and should be exported. The DEProblem type should hold all of the mathematical information about the problem (including all of the meshing information in both space and time), and the DESolution should hold all of the information for the solution. Then all that is required is to define a __solve(::DEProblem,alg;kwargs) which takes in the problem and returns a solution.","category":"page"},{"location":"contributing/defining_problems/","page":"Developing A New Problem","title":"Developing A New Problem","text":"Then to check that the algorithm works, add a dispatch for test_convergence which makes a ConvergenceSimulation type. This type already has a plot recipe, so plotting functionality will already be embedded. This requires that your problem can take in a true solution, and has a field errors which is a dictionary of symbols for the different error estimates (L2,L infinity, etc.)","category":"page"},{"location":"contributing/defining_problems/","page":"Developing A New Problem","title":"Developing A New Problem","text":"After these steps, update the documentation to include the new problem types and the new associated solvers.","category":"page"},{"location":"internals/tableaus/#ODE-Tableaus","page":"ODE Tableaus","title":"ODE Tableaus","text":"","category":"section"},{"location":"internals/tableaus/#Explicit-Runge-Kutta-Methods","page":"ODE Tableaus","title":"Explicit Runge-Kutta Methods","text":"","category":"section"},{"location":"internals/tableaus/","page":"ODE Tableaus","title":"ODE Tableaus","text":"constructEuler - Euler's 1st order method.\nconstructHeun() Heun's order 2 method.\nconstructRalston() - Ralston's order 2 method.\nconstructSSPRK22() - Explicit SSP method of order 2 using 2 stages.\nconstructKutta3 - Kutta's classic 3rd order method.\nconstructSSPRK33() - Explicit SSP method of order 3 using 3 stages.\nconstructSSPRK43() - Explicit SSP method of order 3 using 4 stages.\nconstructRK4 - The classic 4th order \"Runge-Kutta\" method.\nconstructRK438Rule - The classic 4th order \"3/8th's Rule\" method.\nconstructSSPRK104() - Explicit SSP method of order 4 using 10 stages.\nconstructBogakiShampine3() - Bogakai-Shampine's 2/3 method.\nconstructRKF4() - Runge-Kutta-Fehlberg 3/4.\nconstructRKF5() - Runge-Kutta-Fehlberg 4/5.\nconstructRungeFirst5() - Runge's first 5th order method.\nconstructCassity5() - Cassity's 5th order method.\nconstructLawson5() - Lawson's 5th order method.\nconstructLutherKonen5 - Luther-Konen's first 5th order method.\nconstructLutherKonen52() - Luther-Konen's second 5th order method.\nconstructLutherKonen53() - Luther-Konen's third 5th order method.\nconstructPapakostasPapaGeorgiou5() - Papakostas and PapaGeorgiou more stable order 5 method.\nconstructPapakostasPapaGeorgiou52() - Papakostas and PapaGeorgiou more efficient order 5 method.\nconstructTsitouras5() - Tsitouras's order 5 method.\nconstructBogakiShampine5() - Bogaki and Shampine's Order 5 method.\nconstructSharpSmart5() - Sharp and Smart's Order 5 method.\nconstructCashKarp() - Cash-Karp method 4/5.\nconstructDormandPrince() - Dormand-Prince 4/5.\nconstructButcher6() - Butcher's first order 6 method.\nconstructButcher62() - Butcher's second order 6 method.\nconstructButcher63() - Butcher's third order 6 method.\nconstructDormandPrince6() - Dormand-Prince's 5/6 method.\nconstructSharpVerner6() Sharp-Verner's 5/6 method.\nconstructVerner916() - Verner's more efficient order 6 method (1991).\nconstructVerner9162() - Verner's second more efficient order 6 method (1991).\nconstructVernerRobust6() - Verner's \"most robust\" order 6 method.\nconstructVernerEfficient6() - Verner's \"most efficient\" order 6 method.\nconstructPapakostas6() - Papakostas's order 6 method.\nconstructLawson6() - Lawson's order 6 method.\nconstructTsitourasPapakostas6() - Tsitouras and Papakostas's order 6 method.\nconstructDormandLockyerMcCorriganPrince6() - the Dormand-Lockyer-McCorrigan-Prince order 6 method.\nconstructTanakaKasugaYamashitaYazaki6A() - Tanaka-Kasuga-Yamashita-Yazaki order 6 method A.\nconstructTanakaKasugaYamashitaYazaki6B() - Tanaka-Kasuga-Yamashita-Yazaki order 6 method B.\nconstructTanakaKasugaYamashitaYazaki6C() - Tanaka-Kasuga-Yamashita-Yazaki order 6 method C.\nconstructTanakaKasugaYamashitaYazaki6D() - Tanaka-Kasuga-Yamashita-Yazaki order 6 method D.\nconstructMikkawyEisa() - Mikkawy and Eisa's order 6 method.\nconstructChummund6() - Chummund's first order 6 method.\nconstructChummund62() - Chummund's second order 6 method.\nconstructHuta6() - Huta's first order 6 method.\nconstructHuta62() - Huta's second order 6 method.\nconstructVerner6() - An old order 6 method attributed to Verner.\nconstructDverk() - The classic DVERK algorithm attributed to Verner.\nconstructClassicVerner6() - A classic Verner order 6 algorithm (1978).\nconstructButcher7() - Butcher's order 7 algorithm.\nconstructClassicVerner7()- A classic Verner order 7 algorithm (1978).\nconstructVernerRobust7() - Verner's \"most robust\" order 7 algorithm.\nconstructTanakaYamashitaStable7() - Tanaka-Yamashita more stable order 7 algorithm.\nconstructTanakaYamashitaEfficient7() - Tanaka-Yamashita more efficient order 7 algorithm.\nconstructSharpSmart7() - Sharp-Smart's order 7 algorithm.\nconstructSharpVerner7() - Sharp-Verner's order 7 algorithm.\nconstructVerner7() - Verner's \"most efficient\" order 7 algorithm.\nconstructVernerEfficient7() - Verner's \"most efficient\" order 7 algorithm.\nconstructClassicVerner8() - A classic Verner order 8 algorithm (1978).\nconstructCooperVerner8() - Cooper-Verner's first order 8 algorithm.\nconstructCooperVerner82() - Cooper-Verner's second order 8 algorithm.\nconstructTsitourasPapakostas8() - Tsitouras-Papakostas order 8 algorithm.\nconstructdverk78() - The classic order 8 DVERK algorithm.\nconstructEnrightVerner8() - Enright-Verner order 8 algorithm.\nconstructCurtis8() - Curtis' order 8 algorithm.\nconstructVerner8() - Verner's \"most efficient\" order 8 algorithm.\nconstructRKF8() - Runge-Kutta-Fehlberg Order 7/8 method.\nconstructDormandPrice8() - Dormand-Prince Order 7/8 method.\nconstructDormandPrince8_64bit() - Dormand-Prince Order 7/8 method. Coefficients are rational approximations good for 64 bits.\nconstructVernerRobust9() - Verner's \"most robust\" order 9 method.\nconstructVernerEfficient9() - Verner's \"most efficient\" order 9 method.\nconstructSharp9() - Sharp's order 9 method.\nconstructTsitouras9() - Tsitouras's first order 9 method.\nconstructTsitouras92() - Tsitouras's second order 9 method.\nconstructCurtis10() - Curtis' order 10 method.\nconstructOno10() - Ono's order 10 method.\nconstructFeagin10Tableau() - Feagin's order 10 method.\nconstructCurtis10() - Curtis' order 10 method.\nconstructBaker10() - Baker's order 10 method.\nconstructHairer10() Hairer's order 10 method.\nconstructFeagin12Tableau() - Feagin's order 12 method.\nconstructOno12() - Ono's order 12 method.\nconstructFeagin14Tableau() Feagin's order 14 method.","category":"page"},{"location":"internals/tableaus/#Implicit-Runge-Kutta-Methods","page":"ODE Tableaus","title":"Implicit Runge-Kutta Methods","text":"","category":"section"},{"location":"internals/tableaus/","page":"ODE Tableaus","title":"ODE Tableaus","text":"constructImplicitEuler - The 1st order Implicit Euler method.\nconstructMidpointRule - The 2nd order Midpoint method.\nconstructTrapezoidalRule - The 2nd order Trapezoidal rule (2nd order LobattoIIIA)\nconstructLobattoIIIA4 - The 4th order LobattoIIIA\nconstructLobattoIIIB2 - The 2nd order LobattoIIIB\nconstructLobattoIIIB4 - The 4th order LobattoIIIB\nconstructLobattoIIIC2 - The 2nd order LobattoIIIC\nconstructLobattoIIIC4 - The 4th order LobattoIIIC\nconstructLobattoIIICStar2 - The 2nd order LobattoIIIC*\nconstructLobattoIIICStar4 - The 4th order LobattoIIIC*\nconstructLobattoIIID2 - The 2nd order LobattoIIID\nconstructLobattoIIID4 - The 4th order LobattoIIID\nconstructRadauIA3 - The 3rd order RadauIA\nconstructRadauIA5 - The 5th order RadauIA\nconstructRadauIIA3 - The 3rd order RadauIIA\nconstructRadauIIA5 - The 5th order RadauIIA","category":"page"},{"location":"internals/tableaus/#Tableau-Methods","page":"ODE Tableaus","title":"Tableau Methods","text":"","category":"section"},{"location":"internals/tableaus/","page":"ODE Tableaus","title":"ODE Tableaus","text":"DiffEqDevTools.stability_region\nOrdinaryDiffEq.ODE_DEFAULT_TABLEAU","category":"page"},{"location":"internals/tableaus/#DiffEqDevTools.stability_region","page":"ODE Tableaus","title":"DiffEqDevTools.stability_region","text":"stability_region(z,tab::ODERKTableau)\n\nCalculates the stability function from the tableau at z. Stable if <1.\n\nr(z) = 1 + z bᵀ(I - zA)¹ e\n\nwhere e denotes a vector of ones.\n\n\n\n\n\nstability_region(tab::ODERKTableau; initial_guess=-3.0)\n\nCalculates the length of the stability region in the real axis.\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#OrdinaryDiffEq.ODE_DEFAULT_TABLEAU","page":"ODE Tableaus","title":"OrdinaryDiffEq.ODE_DEFAULT_TABLEAU","text":"ODEDEFAULTTABLEAU\n\nSets the default tableau for the ODE solver. Currently Dormand-Prince 4/5.\n\n\n\n\n\n","category":"constant"},{"location":"internals/tableaus/#Explicit-Tableaus","page":"ODE Tableaus","title":"Explicit Tableaus","text":"","category":"section"},{"location":"internals/tableaus/","page":"ODE Tableaus","title":"ODE Tableaus","text":"DiffEqDevTools.constructEuler\nDiffEqDevTools.constructRalston\nDiffEqDevTools.constructHeun\nDiffEqDevTools.constructKutta3\nOrdinaryDiffEq.constructBS3\nDiffEqDevTools.constructBogakiShampine3\nDiffEqDevTools.constructRK4\nDiffEqDevTools.constructRK438Rule\nDiffEqDevTools.constructRKF4\nDiffEqDevTools.constructRKF5\nDiffEqDevTools.constructCashKarp\nDiffEqDevTools.constructDormandPrince\nOrdinaryDiffEq.constructBS5\nDiffEqDevTools.constructPapakostasPapaGeorgiou5\nDiffEqDevTools.constructPapakostasPapaGeorgiou52\nDiffEqDevTools.constructTsitouras5\nDiffEqDevTools.constructLutherKonen5\nDiffEqDevTools.constructLutherKonen52\nDiffEqDevTools.constructLutherKonen53\nDiffEqDevTools.constructRungeFirst5\nDiffEqDevTools.constructLawson5\nDiffEqDevTools.constructSharpSmart5\nDiffEqDevTools.constructBogakiShampine5\nDiffEqDevTools.constructCassity5\nDiffEqDevTools.constructButcher6\nDiffEqDevTools.constructButcher62\nDiffEqDevTools.constructButcher63\nDiffEqDevTools.constructVernerRobust6\nDiffEqDevTools.constructTanakaKasugaYamashitaYazaki6A\nDiffEqDevTools.constructTanakaKasugaYamashitaYazaki6B\nDiffEqDevTools.constructTanakaKasugaYamashitaYazaki6C\nDiffEqDevTools.constructTanakaKasugaYamashitaYazaki6D\nDiffEqDevTools.constructHuta6\nDiffEqDevTools.constructHuta62\nDiffEqDevTools.constructVerner6\nDiffEqDevTools.constructDormandPrince6\nDiffEqDevTools.constructSharpVerner6\nDiffEqDevTools.constructVern6\nDiffEqDevTools.constructClassicVerner6\nDiffEqDevTools.constructChummund6\nDiffEqDevTools.constructChummund62\nDiffEqDevTools.constructPapakostas6\nDiffEqDevTools.constructLawson6\nDiffEqDevTools.constructTsitourasPapakostas6\nDiffEqDevTools.constructDormandLockyerMcCorriganPrince6\nDiffEqDevTools.constructVernerEfficient6\nDiffEqDevTools.constructMikkawyEisa\nDiffEqDevTools.constructVernerEfficient7\nDiffEqDevTools.constructClassicVerner7\nDiffEqDevTools.constructSharpVerner7\nDiffEqDevTools.constructTanakaYamashitaStable7\nDiffEqDevTools.constructSharpSmart7\nDiffEqDevTools.constructTanakaYamashitaEfficient7\nDiffEqDevTools.constructVernerRobust7\nOrdinaryDiffEq.constructTanYam7\nDiffEqDevTools.constructEnrightVerner7\nDiffEqDevTools.constructDormandPrince8\nDiffEqDevTools.constructRKF8\nDiffEqDevTools.constructCooperVerner8\nDiffEqDevTools.constructCooperVerner82\nDiffEqDevTools.constructTsitourasPapakostas8\nDiffEqDevTools.constructEnrightVerner8\nDiffEqDevTools.constructdverk78\nDiffEqDevTools.constructClassicVerner8\nDiffEqDevTools.constructDormandPrince8_64bit\nDiffEqDevTools.constructCurtis8\nOrdinaryDiffEq.constructTsitPap8\nDiffEqDevTools.constructSharp9\nDiffEqDevTools.constructTsitouras9\nDiffEqDevTools.constructTsitouras92\nDiffEqDevTools.constructVernerEfficient9\nOrdinaryDiffEq.constructVern9\nDiffEqDevTools.constructVerner916\nDiffEqDevTools.constructVerner9162\nDiffEqDevTools.constructVernerRobust9\nDiffEqDevTools.constructFeagin10\nDiffEqDevTools.constructFeagin10Tableau\nDiffEqDevTools.constructOno10\nDiffEqDevTools.constructCurtis10\nDiffEqDevTools.constructHairer10\nDiffEqDevTools.constructBaker10\nDiffEqDevTools.constructFeagin12\nDiffEqDevTools.constructOno12\nDiffEqDevTools.constructFeagin12Tableau\nDiffEqDevTools.constructFeagin14\nDiffEqDevTools.constructFeagin14Tableau","category":"page"},{"location":"internals/tableaus/#DiffEqDevTools.constructEuler","page":"ODE Tableaus","title":"DiffEqDevTools.constructEuler","text":"Euler's method.\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructRalston","page":"ODE Tableaus","title":"DiffEqDevTools.constructRalston","text":"Ralston's Order 2 method.\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructHeun","page":"ODE Tableaus","title":"DiffEqDevTools.constructHeun","text":"Heun's Order 2 method.\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructKutta3","page":"ODE Tableaus","title":"DiffEqDevTools.constructKutta3","text":"Kutta's Order 3 method.\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructBogakiShampine3","page":"ODE Tableaus","title":"DiffEqDevTools.constructBogakiShampine3","text":"constructBogakiShampine3()\n\nConstructs the tableau object for the Bogakai-Shampine Order 2/3 method.\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructRK4","page":"ODE Tableaus","title":"DiffEqDevTools.constructRK4","text":"Classic RK4 method.\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructRK438Rule","page":"ODE Tableaus","title":"DiffEqDevTools.constructRK438Rule","text":"Classic RK4 3/8's rule method.\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructRKF4","page":"ODE Tableaus","title":"DiffEqDevTools.constructRKF4","text":"Runge-Kutta-Fehberg Order 4/3\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructRKF5","page":"ODE Tableaus","title":"DiffEqDevTools.constructRKF5","text":"Runge-Kutta-Fehlberg Order 4/5 method.\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructCashKarp","page":"ODE Tableaus","title":"DiffEqDevTools.constructCashKarp","text":"constructCashKarp()\n\nConstructs the tableau object for the Cash-Karp Order 4/5 method.\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructPapakostasPapaGeorgiou5","page":"ODE Tableaus","title":"DiffEqDevTools.constructPapakostasPapaGeorgiou5","text":"S.N. Papakostas and G. PapaGeorgiou higher error more stable\n\nA Family of Fifth-order Runge-Kutta Pairs, by S.N. Papakostas and G. PapaGeorgiou,  Mathematics of Computation,Volume 65, Number 215, July 1996, Pages 1165-1181.\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructPapakostasPapaGeorgiou52","page":"ODE Tableaus","title":"DiffEqDevTools.constructPapakostasPapaGeorgiou52","text":"S.N. Papakostas and G. PapaGeorgiou less stable lower error  Strictly better than DP5\n\nA Family of Fifth-order Runge-Kutta Pairs, by S.N. Papakostas and G. PapaGeorgiou,  Mathematics of Computation,Volume 65, Number 215, July 1996, Pages 1165-1181.\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructTsitouras5","page":"ODE Tableaus","title":"DiffEqDevTools.constructTsitouras5","text":"Runge–Kutta pairs of orders 5(4) using the minimal set of simplifying assumptions,  by Ch. Tsitouras, TEI of Chalkis, Dept. of Applied Sciences, GR34400, Psahna, Greece.\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructLutherKonen5","page":"ODE Tableaus","title":"DiffEqDevTools.constructLutherKonen5","text":"Luther and Konen's First Order 5 Some Fifth-Order Classical Runge Kutta Formulas, H.A.Luther and H.P.Konen,  Siam Review, Vol. 3, No. 7, (Oct., 1965) pages 551-558.\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructLutherKonen52","page":"ODE Tableaus","title":"DiffEqDevTools.constructLutherKonen52","text":"Luther and Konen's Second Order 5 Some Fifth-Order Classical Runge Kutta Formulas, H.A.Luther and H.P.Konen,  Siam Review, Vol. 3, No. 7, (Oct., 1965) pages 551-558.\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructLutherKonen53","page":"ODE Tableaus","title":"DiffEqDevTools.constructLutherKonen53","text":"Luther and Konen's Third Order 5 Some Fifth-Order Classical Runge Kutta Formulas, H.A.Luther and H.P.Konen,  Siam Review, Vol. 3, No. 7, (Oct., 1965) pages 551-558.\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructRungeFirst5","page":"ODE Tableaus","title":"DiffEqDevTools.constructRungeFirst5","text":"Runge's First Order 5 method\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructLawson5","page":"ODE Tableaus","title":"DiffEqDevTools.constructLawson5","text":"Lawson's 5th order scheme\n\nAn Order Five Runge Kutta Process with Extended Region of Stability, J. Douglas Lawson,  Siam Journal on Numerical Analysis, Vol. 3, No. 4, (Dec., 1966) pages 593-597\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructSharpSmart5","page":"ODE Tableaus","title":"DiffEqDevTools.constructSharpSmart5","text":"Explicit Runge-Kutta Pairs with One More Derivative Evaluation than the Minimum, by P.W.Sharp and E.Smart,  Siam Journal of Scientific Computing, Vol. 14, No. 2, pages. 338-348, March 1993.\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructBogakiShampine5","page":"ODE Tableaus","title":"DiffEqDevTools.constructBogakiShampine5","text":"An Efficient Runge-Kutta (4,5) Pair by P.Bogacki and L.F.Shampine  Computers and Mathematics with Applications, Vol. 32, No. 6, 1996, pages 15 to 28\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructCassity5","page":"ODE Tableaus","title":"DiffEqDevTools.constructCassity5","text":"Cassity's Order 5 method\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructButcher6","page":"ODE Tableaus","title":"DiffEqDevTools.constructButcher6","text":"Butcher's First Order 6 method\n\nOn Runge-Kutta Processes of High Order, by J. C. Butcher,  Journal of the Australian Mathematical Society, Vol. 4, (1964), pages 179 to 194\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructButcher62","page":"ODE Tableaus","title":"DiffEqDevTools.constructButcher62","text":"Butcher's Second Order 6 method\n\nOn Runge-Kutta Processes of High Order, by J. C. Butcher,  Journal of the Australian Mathematical Society, Vol. 4, (1964), pages 179 to 194\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructButcher63","page":"ODE Tableaus","title":"DiffEqDevTools.constructButcher63","text":"Butcher's Third Order 6\n\nOn Runge-Kutta Processes of High Order, by J. C. Butcher,  Journal of the Australian Mathematical Society, Vol. 4, (1964), pages 179 to 194\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructVernerRobust6","page":"ODE Tableaus","title":"DiffEqDevTools.constructVernerRobust6","text":"From Verner's Website\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructTanakaKasugaYamashitaYazaki6A","page":"ODE Tableaus","title":"DiffEqDevTools.constructTanakaKasugaYamashitaYazaki6A","text":"TanakaKasugaYamashitaYazaki Order 6 A\n\nOn the Optimization of Some Eight-stage Sixth-order Explicit Runge-Kutta Method,  by M. Tanaka, K. Kasuga, S. Yamashita and H. Yazaki,  Journal of the Information Processing Society of Japan, Vol. 34, No. 1 (1993), pages 62 to 74.\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructTanakaKasugaYamashitaYazaki6B","page":"ODE Tableaus","title":"DiffEqDevTools.constructTanakaKasugaYamashitaYazaki6B","text":"constructTanakaKasugaYamashitaYazaki Order 6 B\n\nOn the Optimization of Some Eight-stage Sixth-order Explicit Runge-Kutta Method,  by M. Tanaka, K. Kasuga, S. Yamashita and H. Yazaki,  Journal of the Information Processing Society of Japan, Vol. 34, No. 1 (1993), pages 62 to 74.\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructTanakaKasugaYamashitaYazaki6C","page":"ODE Tableaus","title":"DiffEqDevTools.constructTanakaKasugaYamashitaYazaki6C","text":"constructTanakaKasugaYamashitaYazaki Order 6 C\n\nOn the Optimization of Some Eight-stage Sixth-order Explicit Runge-Kutta Method,  by M. Tanaka, K. Kasuga, S. Yamashita and H. Yazaki,  Journal of the Information Processing Society of Japan, Vol. 34, No. 1 (1993), pages 62 to 74.\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructTanakaKasugaYamashitaYazaki6D","page":"ODE Tableaus","title":"DiffEqDevTools.constructTanakaKasugaYamashitaYazaki6D","text":"constructTanakaKasugaYamashitaYazaki Order 6 D\n\nOn the Optimization of Some Eight-stage Sixth-order Explicit Runge-Kutta Method,  by M. Tanaka, K. Kasuga, S. Yamashita and H. Yazaki,  Journal of the Information Processing Society of Japan, Vol. 34, No. 1 (1993), pages 62 to 74.\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructHuta6","page":"ODE Tableaus","title":"DiffEqDevTools.constructHuta6","text":"Anton Hutas First Order 6 method\n\nUne amélioration de la méthode de Runge-Kutta-Nyström pour la résolution numérique des équations différentielles du premièr ordre, by Anton Huta, Acta Fac. Nat. Univ. Comenian Math., Vol. 1, pages 201-224 (1956).\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructHuta62","page":"ODE Tableaus","title":"DiffEqDevTools.constructHuta62","text":"Anton Hutas Second Order 6 method\n\nUne amélioration de la méthode de Runge-Kutta-Nyström pour la résolution numérique des équations différentielles du premièr ordre, by Anton Huta, Acta Fac. Nat. Univ. Comenian Math., Vol. 1, pages 201-224 (1956).\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructVerner6","page":"ODE Tableaus","title":"DiffEqDevTools.constructVerner6","text":"Verner Order 5/6 method\n\nA Contrast of a New RK56 pair with DP56, by Jim Verner,  Department of Mathematics. Simon Fraser University, Burnaby, Canada, 2006.\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructDormandPrince6","page":"ODE Tableaus","title":"DiffEqDevTools.constructDormandPrince6","text":"Dormand-Prince Order 5//6 method\n\nP.J. Prince and J. R. Dormand, High order embedded Runge-Kutta formulae, Journal of Computational and Applied Mathematics . 7 (1981), pp. 67-75.\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructSharpVerner6","page":"ODE Tableaus","title":"DiffEqDevTools.constructSharpVerner6","text":"Sharp-Verner Order 5/6 method\n\nCompletely Imbedded Runge-Kutta Pairs, by P. W. Sharp and J. H. Verner,  SIAM Journal on Numerical Analysis, Vol. 31, No. 4. (Aug., 1994), pages. 1169 to 1190.\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructClassicVerner6","page":"ODE Tableaus","title":"DiffEqDevTools.constructClassicVerner6","text":"EXPLICIT RUNGE-KUTTA METHODS WITH ESTIMATES OF THE LOCAL TRUNCATION ERROR\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructChummund6","page":"ODE Tableaus","title":"DiffEqDevTools.constructChummund6","text":"Chummund's First Order 6 method\n\nA three-dimensional family of seven-step Runge-Kutta methods of order 6, by G. M. Chammud (Hammud), Numerical Methods and programming, 2001, Vol.2, 2001, pages 159-166 (Advanced Computing Scientific journal published by the Research Computing Center of the Lomonosov Moscow State Univeristy)\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructChummund62","page":"ODE Tableaus","title":"DiffEqDevTools.constructChummund62","text":"Chummund's Second Order 6 method\n\nA three-dimensional family of seven-step Runge-Kutta methods of order 6, by G. M. Chammud (Hammud), Numerical Methods and programming, 2001, Vol.2, 2001, pages 159-166 (Advanced Computing Scientific journal published by the Research Computing Center of the Lomonosov Moscow State Univeristy)\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructPapakostas6","page":"ODE Tableaus","title":"DiffEqDevTools.constructPapakostas6","text":"Papakostas's Order 6\n\nOn Phase-Fitted modified Runge-Kutta Pairs of order 6(5), by Ch. Tsitouras and I. Th. Famelis,  International Conference of Numerical Analysis and Applied Mathematics, Crete, (2006)\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructLawson6","page":"ODE Tableaus","title":"DiffEqDevTools.constructLawson6","text":"Lawson's Order 6\n\nAn Order 6 Runge-Kutta Process with an Extended Region of Stability, by J. D. Lawson,  Siam Journal on Numerical Analysis, Vol. 4, No. 4 (Dec. 1967) pages 620-625.\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructTsitourasPapakostas6","page":"ODE Tableaus","title":"DiffEqDevTools.constructTsitourasPapakostas6","text":"Tsitouras-Papakostas's Order 6\n\nCheap Error Estimation for Runge-Kutta methods, by Ch. Tsitouras and S.N. Papakostas, Siam Journal on Scientific Computing, Vol. 20, Issue 6, Nov 1999.\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructDormandLockyerMcCorriganPrince6","page":"ODE Tableaus","title":"DiffEqDevTools.constructDormandLockyerMcCorriganPrince6","text":"DormandLockyerMcCorriganPrince Order 6 Global Error Estimation\n\nGlobal Error estimation with Runge-Kutta triples, by J.R.Dormand, M.A.Lockyer, N.E.McCorrigan and P.J.Prince,  Computers and Mathematics with Applications, 18 (1989) pages 835-846.\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructVernerEfficient6","page":"ODE Tableaus","title":"DiffEqDevTools.constructVernerEfficient6","text":"From Verner's Website\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructMikkawyEisa","page":"ODE Tableaus","title":"DiffEqDevTools.constructMikkawyEisa","text":"Mikkawy-Eisa Order 6\n\nA general four-parameter non-FSAL embedded Runge–Kutta algorithm of orders 6 and 4 in seven stages,  by M.E.A. El-Mikkawy and M.M.M. Eisa,  Applied Mathematics and Computation, Vol. 143, No. 2, (2003) pages 259 to 267.\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructVernerEfficient7","page":"ODE Tableaus","title":"DiffEqDevTools.constructVernerEfficient7","text":"From Verner's website\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructClassicVerner7","page":"ODE Tableaus","title":"DiffEqDevTools.constructClassicVerner7","text":"EXPLICIT RUNGE-KUTTA METHODS WITH ESTIMATES OF THE LOCAL TRUNCATION ERROR\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructSharpVerner7","page":"ODE Tableaus","title":"DiffEqDevTools.constructSharpVerner7","text":"Completely Imbedded Runge-Kutta Pairs, by P.W.Sharp and J.H.Verner, Siam Journal on Numerical Analysis, Vol.31, No.4. (August 1994) pages 1169-1190.\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructTanakaYamashitaStable7","page":"ODE Tableaus","title":"DiffEqDevTools.constructTanakaYamashitaStable7","text":"On the Optimization of Some Nine-Stage Seventh-order Runge-Kutta Method, by M. Tanaka, S. Muramatsu and S. Yamashita, Information Processing Society of Japan, Vol. 33, No. 12 (1992) pages 1512-1526.\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructSharpSmart7","page":"ODE Tableaus","title":"DiffEqDevTools.constructSharpSmart7","text":"Explicit Runge-Kutta Pairs with One More Derivative Evaluation than the Minimum, by P.W.Sharp and E.Smart,  Siam Journal of Scientific Computing, Vol. 14, No. 2, pages. 338-348, March 1993.\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructTanakaYamashitaEfficient7","page":"ODE Tableaus","title":"DiffEqDevTools.constructTanakaYamashitaEfficient7","text":"On the Optimization of Some Nine-Stage Seventh-order Runge-Kutta Method, by M. Tanaka, S. Muramatsu and S. Yamashita, Information Processing Society of Japan, Vol. 33, No. 12 (1992) pages 1512-1526.\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructVernerRobust7","page":"ODE Tableaus","title":"DiffEqDevTools.constructVernerRobust7","text":"From Verner's website\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructEnrightVerner7","page":"ODE Tableaus","title":"DiffEqDevTools.constructEnrightVerner7","text":"The Relative Efficiency of Alternative Defect Control Schemes for High-Order Continuous Runge-Kutta Formulas  W. H. Enright SIAM Journal on Numerical Analysis, Vol. 30, No. 5. (Oct., 1993), pp. 1419-1445.\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructDormandPrince8","page":"ODE Tableaus","title":"DiffEqDevTools.constructDormandPrince8","text":"constructDormandPrice8()\n\nConstructs the tableau object for the Dormand-Prince Order 6/8 method.\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructRKF8","page":"ODE Tableaus","title":"DiffEqDevTools.constructRKF8","text":"constructRKF8()\n\nConstructs the tableau object for the Runge-Kutta-Fehlberg Order 7/8 method.\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructCooperVerner8","page":"ODE Tableaus","title":"DiffEqDevTools.constructCooperVerner8","text":"Some Explicit Runge-Kutta Methods of High Order, by G. J. Cooper and J. H. Verner,  SIAM Journal on Numerical Analysis, Vol. 9, No. 3, (September 1972), pages 389 to 405\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructCooperVerner82","page":"ODE Tableaus","title":"DiffEqDevTools.constructCooperVerner82","text":"Some Explicit Runge-Kutta Methods of High Order, by G. J. Cooper and J. H. Verner,  SIAM Journal on Numerical Analysis, Vol. 9, No. 3, (September 1972), pages 389 to 405\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructTsitourasPapakostas8","page":"ODE Tableaus","title":"DiffEqDevTools.constructTsitourasPapakostas8","text":"Cheap Error Estimation for Runge-Kutta methods, by Ch. Tsitouras and S.N. Papakostas,  Siam Journal on Scientific Computing, Vol. 20, Issue 6, Nov 1999.\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructEnrightVerner8","page":"ODE Tableaus","title":"DiffEqDevTools.constructEnrightVerner8","text":"The Relative Efficiency of Alternative Defect Control Schemes for High-Order Continuous Runge-Kutta Formulas  W. H. Enright SIAM Journal on Numerical Analysis, Vol. 30, No. 5. (Oct., 1993), pp. 1419-1445.\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructdverk78","page":"ODE Tableaus","title":"DiffEqDevTools.constructdverk78","text":"Jim Verner's \"Maple\" (dverk78)\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructClassicVerner8","page":"ODE Tableaus","title":"DiffEqDevTools.constructClassicVerner8","text":"EXPLICIT RUNGE-KUTTA METHODS WITH ESTIMATES OF THE LOCAL TRUNCATION ERROR\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructDormandPrince8_64bit","page":"ODE Tableaus","title":"DiffEqDevTools.constructDormandPrince8_64bit","text":"constructDormandPrice8_64bit()\n\nConstructs the tableau object for the Dormand-Prince Order 6/8 method with the approximated coefficients from the paper. This works until below 64-bit precision.\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructCurtis8","page":"ODE Tableaus","title":"DiffEqDevTools.constructCurtis8","text":"An Eighth Order Runge-Kutta process with Eleven Function Evaluations per Step, by A. R. Curtis,  Numerische Mathematik, Vol. 16, No. 3 (1970), pages 268 to 277\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructSharp9","page":"ODE Tableaus","title":"DiffEqDevTools.constructSharp9","text":"Journal of Applied Mathematics & Decision Sciences, 4(2), 183-192 (2000),  \"High order explicit Runge-Kutta pairs for ephemerides of the Solar System and the Moon\".\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructTsitouras9","page":"ODE Tableaus","title":"DiffEqDevTools.constructTsitouras9","text":"Optimized explicit Runge-Kutta pairs of order 9(8), by Ch. Tsitouras,  Applied Numerical Mathematics, 38 (2001) 123-134.\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructTsitouras92","page":"ODE Tableaus","title":"DiffEqDevTools.constructTsitouras92","text":"Optimized explicit Runge-Kutta pairs of order 9(8), by Ch. Tsitouras,  Applied Numerical Mathematics, 38 (2001) 123-134.\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructVernerEfficient9","page":"ODE Tableaus","title":"DiffEqDevTools.constructVernerEfficient9","text":"From Verner's Webiste\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructVerner916","page":"ODE Tableaus","title":"DiffEqDevTools.constructVerner916","text":"Verner 1991 First Order 5/6 method\n\nSome Ruge-Kutta Formula Pairs, by J.H.Verner,  SIAM Journal on Numerical Analysis, Vol. 28, No. 2 (April 1991), pages 496 to 511.\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructVerner9162","page":"ODE Tableaus","title":"DiffEqDevTools.constructVerner9162","text":"Verner 1991 Second Order 5/6 method\n\nSome Ruge-Kutta Formula Pairs, by J.H.Verner,  SIAM Journal on Numerical Analysis, Vol. 28, No. 2 (April 1991), pages 496 to 511.\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructVernerRobust9","page":"ODE Tableaus","title":"DiffEqDevTools.constructVernerRobust9","text":"From Verner's Webiste\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructFeagin10","page":"ODE Tableaus","title":"DiffEqDevTools.constructFeagin10","text":"Feagin10 in Tableau form\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructOno10","page":"ODE Tableaus","title":"DiffEqDevTools.constructOno10","text":"Ono10\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructCurtis10","page":"ODE Tableaus","title":"DiffEqDevTools.constructCurtis10","text":"High-order Explicit Runge-Kutta Formulae, Their uses, and Limitations, A.R.Curtis, J. Inst. Maths Applics (1975) 16, 35-55.\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructHairer10","page":"ODE Tableaus","title":"DiffEqDevTools.constructHairer10","text":"A Runge-Kutta Method of Order 10, E. Hairer, J. Inst. Maths Applics (1978) 21, 47-59.\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructBaker10","page":"ODE Tableaus","title":"DiffEqDevTools.constructBaker10","text":"Tom Baker, University of Teeside. Part of RK-Aid http://www.scm.tees.ac.uk/users/u0000251/research/researcht.htm http://www.scm.tees.ac.uk/users/u0000251/j.r.dormand/t.baker/rk10921m/rk10921m\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructFeagin12","page":"ODE Tableaus","title":"DiffEqDevTools.constructFeagin12","text":"Tableau form of Feagin12\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructOno12","page":"ODE Tableaus","title":"DiffEqDevTools.constructOno12","text":"On the 25 stage 12th order explicit Runge-Kutta method, by Hiroshi Ono. Transactions of the Japan Society for Industrial and applied Mathematics, Vol. 6, No. 3, (2006) pages 177 to 186\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructFeagin14","page":"ODE Tableaus","title":"DiffEqDevTools.constructFeagin14","text":"Tableau form of Feagin14\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#Implicit-Tableaus","page":"ODE Tableaus","title":"Implicit Tableaus","text":"","category":"section"},{"location":"internals/tableaus/","page":"ODE Tableaus","title":"ODE Tableaus","text":"DiffEqDevTools.constructImplicitEuler\nDiffEqDevTools.constructMidpointRule\nDiffEqDevTools.constructTrapezoidalRule\nDiffEqDevTools.constructLobattoIIIA4\nDiffEqDevTools.constructLobattoIIIB2\nDiffEqDevTools.constructLobattoIIIB4\nDiffEqDevTools.constructLobattoIIIC2\nDiffEqDevTools.constructLobattoIIIC4\nDiffEqDevTools.constructLobattoIIICStar2\nDiffEqDevTools.constructLobattoIIICStar4\nDiffEqDevTools.constructLobattoIIID2\nDiffEqDevTools.constructLobattoIIID4\nDiffEqDevTools.constructGL2\nDiffEqDevTools.constructGL4\nDiffEqDevTools.constructGL6\nDiffEqDevTools.constructRadauIA3\nDiffEqDevTools.constructRadauIA5\nDiffEqDevTools.constructRadauIIA3\nDiffEqDevTools.constructRadauIIA5","category":"page"},{"location":"internals/tableaus/#DiffEqDevTools.constructImplicitEuler","page":"ODE Tableaus","title":"DiffEqDevTools.constructImplicitEuler","text":"Implicit Euler Method\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructMidpointRule","page":"ODE Tableaus","title":"DiffEqDevTools.constructMidpointRule","text":"Order 2 Midpoint Method\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructTrapezoidalRule","page":"ODE Tableaus","title":"DiffEqDevTools.constructTrapezoidalRule","text":"Order 2 Trapezoidal Rule (LobattoIIIA2)\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructLobattoIIIA4","page":"ODE Tableaus","title":"DiffEqDevTools.constructLobattoIIIA4","text":"LobattoIIIA Order 4 method\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructLobattoIIIB2","page":"ODE Tableaus","title":"DiffEqDevTools.constructLobattoIIIB2","text":"LobattoIIIB Order 2 method\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructLobattoIIIB4","page":"ODE Tableaus","title":"DiffEqDevTools.constructLobattoIIIB4","text":"LobattoIIIB Order 4 method\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructLobattoIIIC2","page":"ODE Tableaus","title":"DiffEqDevTools.constructLobattoIIIC2","text":"LobattoIIIC Order 2 method\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructLobattoIIIC4","page":"ODE Tableaus","title":"DiffEqDevTools.constructLobattoIIIC4","text":"LobattoIIIC Order 4 method\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructLobattoIIICStar2","page":"ODE Tableaus","title":"DiffEqDevTools.constructLobattoIIICStar2","text":"LobattoIIIC* Order 2 method\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructLobattoIIICStar4","page":"ODE Tableaus","title":"DiffEqDevTools.constructLobattoIIICStar4","text":"LobattoIIIC* Order 4 method\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructLobattoIIID2","page":"ODE Tableaus","title":"DiffEqDevTools.constructLobattoIIID2","text":"LobattoIIID Order 2 method\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructLobattoIIID4","page":"ODE Tableaus","title":"DiffEqDevTools.constructLobattoIIID4","text":"LobattoIIID Order 4 method\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructGL2","page":"ODE Tableaus","title":"DiffEqDevTools.constructGL2","text":"Gauss-Legendre Order 2.\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructGL4","page":"ODE Tableaus","title":"DiffEqDevTools.constructGL4","text":"Gauss-Legendre Order 4.\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructGL6","page":"ODE Tableaus","title":"DiffEqDevTools.constructGL6","text":"Gauss-Legendre Order 6.\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructRadauIA3","page":"ODE Tableaus","title":"DiffEqDevTools.constructRadauIA3","text":"RadauIA Order 3 method\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructRadauIA5","page":"ODE Tableaus","title":"DiffEqDevTools.constructRadauIA5","text":"RadauIA Order 5 method\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructRadauIIA3","page":"ODE Tableaus","title":"DiffEqDevTools.constructRadauIIA3","text":"RadauIIA Order 3 method\n\n\n\n\n\n","category":"function"},{"location":"internals/tableaus/#DiffEqDevTools.constructRadauIIA5","page":"ODE Tableaus","title":"DiffEqDevTools.constructRadauIIA5","text":"RadauIIA Order 5 method\n\n\n\n\n\n","category":"function"},{"location":"alg_dev/convergence/#Convergence-Simulations","page":"Convergence Simulations","title":"Convergence Simulations","text":"","category":"section"},{"location":"alg_dev/convergence/","page":"Convergence Simulations","title":"Convergence Simulations","text":"The convergence simulation type is useful for deriving order of convergence estimates from a group of simulations. This object will automatically assemble error vectors into a more useful manner and provide plotting functionality. Convergence estimates are also given by pair-wise estimates.","category":"page"},{"location":"alg_dev/convergence/","page":"Convergence Simulations","title":"Convergence Simulations","text":"One can automatically have DifferentialEquations.jl perform the error analysis by passing a ConvergenceSimulation a vector of solutions, or using one of the provided test_convergence functions. These will give order of convergence estimates and provide plotting functionality. This requires that the true solution was provided in the problem definition.","category":"page"},{"location":"alg_dev/convergence/","page":"Convergence Simulations","title":"Convergence Simulations","text":"ConvergenceSimulations can either be created by passing the constructor the appropriate solution array or by using one of the provided test_convergence functions.","category":"page"},{"location":"alg_dev/convergence/#The-ConvergenceSimulation-Type","page":"Convergence Simulations","title":"The ConvergenceSimulation Type","text":"","category":"section"},{"location":"alg_dev/convergence/","page":"Convergence Simulations","title":"Convergence Simulations","text":"A type which holds the data from a convergence simulation.","category":"page"},{"location":"alg_dev/convergence/#Fields","page":"Convergence Simulations","title":"Fields","text":"","category":"section"},{"location":"alg_dev/convergence/","page":"Convergence Simulations","title":"Convergence Simulations","text":"solutions::Array{<:DESolution}: Holds all the PdeSolutions.\nerrors: Dictionary of the error calculations. Can contain:\nh1Errors: Vector of the H1 errors.\nl2Errors: Vector of the L2 errors.\nmaxErrors: Vector of the nodal maximum errors.\nnode2Errors: Vector of the nodal l2 errors.\nN: The number of simulations.\nauxdata: Auxillary data of the convergence simluation. Entries can include:\ndts: The dt's in the simulations.\ndxs: The dx's in the simulations.\nμs: The CFL μ's in the simulations.\nνs: The CFL ν's in the simulations.\n𝒪est: Dictionary of order estimates. Can contain:\nConvEst_h1: The H1 error order of convergence estimate for the convergence simulation.  Generated via log2(error[i+1]/error[i]). Thus only valid if generated by halving/doubling  the dt/dx. If alternate scaling, modify by dividing of log(base,ConvEst_h1)\nConvEst_l2: The L2 error order of convergence estimate for the convergence simulation.  Generated via log2(error[i+1]/error[i]). Thus only valid if generated by halving/doubling  the dt/dx. If alternate scaling, modify by dividing of log(base,ConvEst_l2)\nConvEst_max: The nodal maximum error order of convergence estimate for the convergence simulation.  Generated via log2(error[i+1]/error[i]). Thus only valid if generated by halving/doubling  the dt/dx. If alternate scaling, modify by dividing of log(base,ConvEst_max)\nConvEst_node2: The nodal l2 error order of convergence estimate for the convergence simulation.  Generated via log2(error[i+1]/error[i]). Thus only valid if generated by halving/doubling  the dt/dx. If alternate scaling, modify by dividing of log(base,ConvEst_node2)\nconvergence_axis: The axis along which convergence is calculated. For example, if  we calculate the dt convergence, convergence_axis is the dts used in the calculation.","category":"page"},{"location":"alg_dev/convergence/#Plot-Functions","page":"Convergence Simulations","title":"Plot Functions","text":"","category":"section"},{"location":"alg_dev/convergence/","page":"Convergence Simulations","title":"Convergence Simulations","text":"The plot functionality is provided by a Plots.jl recipe. What is plotted is a line series for each calculated error along the convergence axis. To plot a convergence simulation, simply use:","category":"page"},{"location":"alg_dev/convergence/","page":"Convergence Simulations","title":"Convergence Simulations","text":"plot(sim::ConvergenceSimulation)","category":"page"},{"location":"alg_dev/convergence/","page":"Convergence Simulations","title":"Convergence Simulations","text":"All of the functionality (keyword arguments) provided by Plots.jl are able to be used in this command. Please see the Plots.jl documentation for more information.","category":"page"},{"location":"alg_dev/convergence/#ODE","page":"Convergence Simulations","title":"ODE","text":"","category":"section"},{"location":"alg_dev/convergence/","page":"Convergence Simulations","title":"Convergence Simulations","text":"test_convergence(dts::AbstractArray,prob::AbstractODEProblem)","category":"page"},{"location":"alg_dev/convergence/","page":"Convergence Simulations","title":"Convergence Simulations","text":"Tests the order of the time convergence of the given algorithm on the given problem solved over the given dts. Keyword arguments are passed to the ODE solver.","category":"page"},{"location":"alg_dev/convergence/#SDE","page":"Convergence Simulations","title":"SDE","text":"","category":"section"},{"location":"alg_dev/convergence/","page":"Convergence Simulations","title":"Convergence Simulations","text":"test_convergence(dts::AbstractArray,prob::AbstractSDEProblem)","category":"page"},{"location":"alg_dev/convergence/","page":"Convergence Simulations","title":"Convergence Simulations","text":"Tests the strong order time convergence of the given algorithm on the given problem solved over the given dts. Keyword arguments are passed to the ODE solver. Except:","category":"page"},{"location":"alg_dev/convergence/","page":"Convergence Simulations","title":"Convergence Simulations","text":"numMonte: The number of simulations for each dt. Default is 10000.","category":"page"},{"location":"alg_dev/convergence/#Order-Estimation","page":"Convergence Simulations","title":"Order Estimation","text":"","category":"section"},{"location":"alg_dev/convergence/","page":"Convergence Simulations","title":"Convergence Simulations","text":"calc𝒪estimates(error::Vector{Number})`","category":"page"},{"location":"alg_dev/convergence/","page":"Convergence Simulations","title":"Convergence Simulations","text":"Computes the pairwise convergence estimate for a convergence test done by halving/doubling stepsizes via","category":"page"},{"location":"alg_dev/convergence/","page":"Convergence Simulations","title":"Convergence Simulations","text":"log2(error[i+1]/error[i])","category":"page"},{"location":"alg_dev/convergence/","page":"Convergence Simulations","title":"Convergence Simulations","text":"Returns the mean of the convergence estimates.","category":"page"},{"location":"alg_dev/test_problems/#Test-Problems","page":"Test Problems","title":"Test Problems","text":"","category":"section"},{"location":"alg_dev/test_problems/","page":"Test Problems","title":"Test Problems","text":"For every problem, one can turn it into a test problem by adding analytical to the DEFunction.","category":"page"},{"location":"alg_dev/test_problems/#No-Analytical-Solution","page":"Test Problems","title":"No Analytical Solution","text":"","category":"section"},{"location":"alg_dev/test_problems/","page":"Test Problems","title":"Test Problems","text":"However, in many cases the analytical solution cannot be found, and therefore one uses a low-tolerance calculation as a stand-in for a solution. The JuliaDiffEq ecosystem supports this through the TestSolution type in DiffEqDevTools. There are three constructors. The code is simple, so here it is:","category":"page"},{"location":"alg_dev/test_problems/","page":"Test Problems","title":"Test Problems","text":"type TestSolution <: DESolution\n  t\n  u\n  interp\n  dense\nend\n(T::TestSolution)(t) = T.interp(t)\nTestSolution(t,u) = TestSolution(t,u,nothing,false)\nTestSolution(t,u,interp) = TestSolution(t,u,interp,true)\nTestSolution(interp::DESolution) = TestSolution(nothing,nothing,interp,true)","category":"page"},{"location":"alg_dev/test_problems/","page":"Test Problems","title":"Test Problems","text":"This acts like a solution. When used in conjunction with apprxtrue:","category":"page"},{"location":"alg_dev/test_problems/","page":"Test Problems","title":"Test Problems","text":"appxtrue(sol::AbstractODESolution,sol2::TestSolution)","category":"page"},{"location":"alg_dev/test_problems/","page":"Test Problems","title":"Test Problems","text":"you can use it to build a TestSolution from a problem (like ODETestSolution) which holds the errors  If you only give it t and u, then it can only calculate the final error. If the TestSolution has an interpolation, it will define timeseries and dense errors.","category":"page"},{"location":"alg_dev/test_problems/","page":"Test Problems","title":"Test Problems","text":"(Note: I would like it so that way the timeseries error will be calculated on the times of sol.t in sol2.t which would act nicely with tstops and when interpolations don't exist, but haven't gotten to it!)","category":"page"},{"location":"alg_dev/test_problems/","page":"Test Problems","title":"Test Problems","text":"These can then be passed to other functionality. For example, the benchmarking functions allow one to set appxsol which is a TestSolution for the benchmark solution to calculate errors against, and error_estimate allows one to choose which error estimate to use in the benchmarking (defaults to :final).","category":"page"},{"location":"alg_dev/test_problems/#Related-Functions","page":"Test Problems","title":"Related Functions","text":"","category":"section"},{"location":"alg_dev/test_problems/","page":"Test Problems","title":"Test Problems","text":"DiffEqDevTools.appxtrue","category":"page"},{"location":"alg_dev/test_problems/#DiffEqDevTools.appxtrue","page":"Test Problems","title":"DiffEqDevTools.appxtrue","text":"appxtrue(sol::AbstractODESolution,sol2::TestSolution)\n\nUses the interpolant from the higher order solution sol2 to approximate errors for sol. If sol2 has no interpolant, only the final error is calculated.\n\n\n\n\n\nappxtrue(sol::AbstractODESolution,sol2::AbstractODESolution)\n\nUses the interpolant from the higher order solution sol2 to approximate errors for sol. If sol2 has no interpolant, only the final error is calculated.\n\n\n\n\n\n","category":"function"},{"location":"contributing/adding_algorithms/#Adding-Algorithms","page":"Adding Algorithms","title":"Adding Algorithms","text":"","category":"section"},{"location":"contributing/adding_algorithms/","page":"Adding Algorithms","title":"Adding Algorithms","text":"New algorithms can either be added by extending one of the current solver (or add-on packages), or by contributing a new package to the organization. If it's a new problem (a new PDE, a new type of differential equation, a new subclass of problems for which special methods exist, etc.) then the problem and solution types should be added to DiffEqBase first.","category":"page"},{"location":"contributing/adding_algorithms/","page":"Adding Algorithms","title":"Adding Algorithms","text":"After the problem and solutions are defined, the __solve method should be implemented. It should take in keyword arguments which match the common interface (implement \"as many as possible\"). One should note and document the amount of compatibility with the common interface and Julia-defined types. After that, testing should be done using DiffEqDevTools. Convergence tests and benchmarks should be included to show the effectiveness of the algorithm and the correctness. Do not worry if the algorithm is not \"effective\": the implementation can improve over time and some algorithms are useful just for the comparison they give!","category":"page"},{"location":"contributing/adding_algorithms/","page":"Adding Algorithms","title":"Adding Algorithms","text":"After some development, one may want to document the algorithm in DiffEqBenchmarks and DiffEqTutorials.","category":"page"},{"location":"contributing/adding_algorithms/#Adding-new-algorithms-to-OrdinaryDiffEq","page":"Adding Algorithms","title":"Adding new algorithms to OrdinaryDiffEq","text":"","category":"section"},{"location":"contributing/adding_algorithms/","page":"Adding Algorithms","title":"Adding Algorithms","text":"This recipe has been used to add the strong stability preserving Runge-Kutta methods SSPRK22, SSPRK33, and SSPRK104 to OrdinaryDiffEq. SSPRK22 will be used as an example.","category":"page"},{"location":"contributing/adding_algorithms/","page":"Adding Algorithms","title":"Adding Algorithms","text":"To create a new solver, two (three) types have to be created. The first is the algorithm SSPRK22 used for dispatch, the other ones are the corresponding caches SSPRK22Cache (for inplace updates) and SSPRK22ConstantCache.\nThe algorithm is defined in algorithms.jl as struct SSPRK22 <: OrdinaryDiffEqAlgorithm end. Although it does not have the FSAL property, this is set to true since the derivative at the start and the end of the interval are used for the Hermite interpolation, and so this is FSAL'd so that way only a single extra function evaluation occurs over the whole integration. This is done in alg_utils.jl via isfsal(alg::SSPRK22) = true. Additionally, the order is set in the same file via alg_order(alg::SSPRK22) = 2.\nThe algorithm SSPRK22 is exported in OrdinaryDiffEq.jl.\nIn caches.jl, the two cache types SSPRK22Cache (for inplace updates) and SSPRK22ConstantCache are defined, similarly to the other ones. Note: u_cache(c::SSPRK22Cache) = () and du_cache(c::SSPRK22Cache) = (c.k,c.du,c.fsalfirst) return the parts of the modifiable cache that are changed if the size of the ODE changes.\nA new file perform_step/ssprk_perform_step.jl has been used for the new implementations. For both types of caches, the functions initialize! and perform_step! are defined there.\nFinally, tests are added. A new file test/ode/ode_ssprk_tests.jl is created and included in tests/runtests.jl via @time @testset \"SSPRK Tests\" begin include(\"ode/ode_ssprk_tests.jl\") end.\nAdditionally, regression tests for the dense output are added in test/ode/ode_dense_tests.jl.","category":"page"},{"location":"contributing/adding_algorithms/","page":"Adding Algorithms","title":"Adding Algorithms","text":"For more details, refer to https://github.com/JuliaDiffEq/OrdinaryDiffEq.jl/pull/40","category":"page"},{"location":"contributing/adding_algorithms/#Self-Contained-Example","page":"Adding Algorithms","title":"Self-Contained Example","text":"","category":"section"},{"location":"contributing/adding_algorithms/","page":"Adding Algorithms","title":"Adding Algorithms","text":"using OrdinaryDiffEq\nimport OrdinaryDiffEq: \n      OrdinaryDiffEqAlgorithm, OrdinaryDiffEqMutableCache, OrdinaryDiffEqConstantCache,\n      alg_order, alg_cache, initialize!, perform_step!, trivial_limiter!, constvalue,\n      @muladd, @unpack, @cache, @..\n\nstruct RK_ALG{StageLimiter,StepLimiter} <: OrdinaryDiffEq.OrdinaryDiffEqAlgorithm \n  stage_limiter!::StageLimiter\n  step_limiter!::StepLimiter\nend\nRK_ALG(stage_limiter! = trivial_limiter!) = RK_ALG(stage_limiter!, trivial_limiter!)\nexport RK_ALG\nalg_order(alg::RK_ALG) = 3\n\n@cache struct RK_ALGCache{uType,rateType,StageLimiter,StepLimiter,TabType} <: OrdinaryDiffEqMutableCache\n  u::uType\n  uprev::uType\n  k::rateType\n  tmp::uType\n  u₂::uType\n  fsalfirst::rateType\n  stage_limiter!::StageLimiter\n  step_limiter!::StepLimiter\n  tab::TabType\nend\n\nstruct RK_ALGConstantCache{T,T2} <: OrdinaryDiffEqConstantCache\n  α40::T\n  α41::T\n  α43::T\n  α62::T\n  α65::T\n  β10::T\n  β21::T\n  β32::T\n  β43::T\n  β54::T\n  β65::T\n  c1::T2\n  c2::T2\n  c3::T2\n  c4::T2\n  c5::T2\nend\n\nfunction RK_ALGConstantCache(T, T2)\n  α40 = T(0.476769811285196)\n  α41 = T(0.098511733286064)\n  α43 = T(0.424718455428740)\n  α62 = T(0.155221702560091)\n  α65 = T(0.844778297439909)\n  β10 = T(0.284220721334261)\n  β21 = T(0.284220721334261)\n  β32 = T(0.284220721334261)\n  β43 = T(0.120713785765930)\n  β54 = T(0.284220721334261)\n  β65 = T(0.240103497065900)\n  c1 = T2(0.284220721334261)\n  c2 = T2(0.568441442668522)\n  c3 = T2(0.852662164002783)\n  c4 = T2(0.510854218958172)\n  c5 = T2(0.795074940292433)\n\n  RK_ALGConstantCache(α40, α41, α43, α62, α65, β10, β21, β32, β43, β54, β65, c1, c2, c3, c4, c5)\nend\n\nfunction alg_cache(alg::RK_ALG,u,rate_prototype,uEltypeNoUnits,uBottomEltypeNoUnits,tTypeNoUnits,uprev,uprev2,f,t,dt,reltol,p,calck,::Val{true})\n  tmp = similar(u)\n  u₂ = similar(u)\n  k = zero(rate_prototype)\n  fsalfirst = zero(rate_prototype)\n  tab = RK_ALGConstantCache(real(uBottomEltypeNoUnits), real(tTypeNoUnits))\n  RK_ALGCache(u,uprev,k,tmp,u₂,fsalfirst,alg.stage_limiter!,alg.step_limiter!,tab)\nend\n\nfunction alg_cache(alg::RK_ALG,u,rate_prototype,uEltypeNoUnits,uBottomEltypeNoUnits,tTypeNoUnits,uprev,uprev2,f,t,dt,reltol,p,calck,::Val{false})\n  RK_ALGConstantCache(real(uBottomEltypeNoUnits), real(tTypeNoUnits))\nend\n\nfunction initialize!(integrator,cache::RK_ALGConstantCache)\n  integrator.fsalfirst = integrator.f(integrator.uprev,integrator.p,integrator.t) # Pre-start fsal\n  integrator.destats.nf += 1\n  integrator.kshortsize = 1\n  integrator.k = typeof(integrator.k)(undef, integrator.kshortsize)\n\n  # Avoid undefined entries if k is an array of arrays\n  integrator.fsallast = zero(integrator.fsalfirst)\n  integrator.k[1] = integrator.fsalfirst\nend\n\n@muladd function perform_step!(integrator,cache::RK_ALGConstantCache,repeat_step=false)\n  @unpack t,dt,uprev,u,f,p = integrator\n  @unpack α40,α41,α43,α62,α65,β10,β21,β32,β43,β54,β65,c1,c2,c3,c4,c5 = cache\n\n  # u1 -> stored as u\n  u = uprev + β10 * dt * integrator.fsalfirst\n  k = f(u, p, t+c1*dt)\n  # u2\n  u₂ = u + β21 * dt * k\n  k = f(u₂,p,t+c2*dt)\n  # u3\n  tmp = u₂ + β32 * dt * k\n  k = f(tmp, p, t+c3*dt)\n  # u4\n  tmp = α40 * uprev + α41 * u + α43 * tmp + β43 * dt * k\n  k = f(tmp, p, t+c4*dt)\n  # u5\n  tmp = tmp + β54 * dt * k\n  k = f(tmp, p, t+c5*dt)\n  # u\n  u = α62 * u₂ + α65 * tmp + β65 * dt * k\n\n  integrator.fsallast = f(u, p, t+dt) # For interpolation, then FSAL'd\n  integrator.destats.nf += 6\n  integrator.k[1] = integrator.fsalfirst\n  integrator.u = u\nend\n\nfunction initialize!(integrator,cache::RK_ALGCache)\n  @unpack k,fsalfirst = cache\n  integrator.fsalfirst = fsalfirst\n  integrator.fsallast = k\n  integrator.kshortsize = 1\n  resize!(integrator.k, integrator.kshortsize)\n  integrator.k[1] = integrator.fsalfirst\n  integrator.f(integrator.fsalfirst,integrator.uprev,integrator.p,integrator.t) # FSAL for interpolation\n  integrator.destats.nf += 1\nend\n\n@muladd function perform_step!(integrator,cache::RK_ALGCache,repeat_step=false)\n  @unpack t,dt,uprev,u,f,p = integrator\n  @unpack k,tmp,u₂,fsalfirst,stage_limiter!,step_limiter! = cache\n  @unpack α40,α41,α43,α62,α65,β10,β21,β32,β43,β54,β65,c1,c2,c3,c4,c5 = cache.tab\n\n  # u1 -> stored as u\n  @.. u = uprev + β10 * dt * integrator.fsalfirst\n  stage_limiter!(u, f, p, t+c1*dt)\n  f( k,  u, p, t+c1*dt)\n  # u2\n  @.. u₂ = u + β21 * dt * k\n  stage_limiter!(u₂, f, p, t+c2*dt)\n  f(k,u₂,p,t+c2*dt)\n  # u3\n  @.. tmp = u₂ + β32 * dt * k\n  stage_limiter!(tmp, f, p, t+c3*dt)\n  f( k,  tmp, p, t+c3*dt)\n  # u4\n  @.. tmp = α40 * uprev + α41 * u + α43 * tmp + β43 * dt * k\n  stage_limiter!(tmp, f, p, t+c4*dt)\n  f( k,  tmp, p, t+c4*dt)\n  # u5\n  @.. tmp = tmp + β54 * dt * k\n  stage_limiter!(tmp, f, p, t+c5*dt)\n  f( k,  tmp, p, t+c5*dt)\n  # u\n  @.. u = α62 * u₂ + α65 * tmp + β65 * dt * k\n  stage_limiter!(u, f, p, t+dt)\n  step_limiter!(u, f, p, t+dt)\n  integrator.destats.nf += 6\n  f( k,  u, p, t+dt)\nend\n\n#oop test\nf = ODEFunction((u,p,t)->1.01u,\n            analytic = (u0,p,t) -> u0*exp(1.01t))\nprob = ODEProblem(f,1.01,(0.0,1.0))\nsol = solve(prob,RK_ALG(),dt=0.1)\n\nusing Plots\nplot(sol)\nplot(sol,denseplot=false,plot_analytic=true)\n\nusing DiffEqDevTools\ndts = (1/2) .^ (8:-1:1)\nsim = test_convergence(dts,prob,RK_ALG())\nsim.𝒪est[:final]\nplot(sim)\n\n# Example of a good one!\nsim = test_convergence(dts,prob,BS3())\nsim.𝒪est[:final]\nplot(sim)\n\n#iip test\nf = ODEFunction((du,u,p,t)->(du .= 1.01.*u),\n            analytic = (u0,p,t) -> u0*exp(1.01t))\nprob = ODEProblem(f,[1.01],(0.0,1.0))\nsol = solve(prob,RK_ALG(),dt=0.1)\n\nplot(sol)\nplot(sol,denseplot=false,plot_analytic=true)\n\ndts = (1/2) .^ (8:-1:1)\nsim = test_convergence(dts,prob,RK_ALG())\nsim.𝒪est[:final]\nplot(sim)\n\n# Example of a good one!\nsim = test_convergence(dts,prob,BS3())\nsim.𝒪est[:final]\nplot(sim)","category":"page"},{"location":"contributing/adding_algorithms/#Adding-new-exponential-algorithms","page":"Adding Algorithms","title":"Adding new exponential algorithms","text":"","category":"section"},{"location":"contributing/adding_algorithms/","page":"Adding Algorithms","title":"Adding Algorithms","text":"The exponential algorithms follow the same recipe as the general algorithms, but there are automation utilities that make this easier. It is recommended that you refer to one of the model algorithms for reference:","category":"page"},{"location":"contributing/adding_algorithms/","page":"Adding Algorithms","title":"Adding Algorithms","text":"For traditional exponential Runge-Kutta type methods (that come with a corresponding Butcher table), refer to ETDRK2.\nFor adaptive exponential Rosenbrock type methods, refer to Exprb32.\nFor exponential propagation iterative Runge-Kutta methods (EPIRK), refer to EPIRK5P1.","category":"page"},{"location":"contributing/adding_algorithms/","page":"Adding Algorithms","title":"Adding Algorithms","text":"The first two classes support two modes of operation: operator caching and Krylov approximation. The perform_step! method in perform_step/exponential_rk_perform_step.jl, as a result, is split into two branches depending on whether alg.krylov is true. The caching branch utilizes precomputed operators, which are calculated by the expRK_operators method in caches/linear_nonlinear_caches.jl. Both expRK_operators and the arnoldi/phiv methods in perform_step! comes from the ExponentialUtilities package.","category":"page"},{"location":"contributing/adding_algorithms/","page":"Adding Algorithms","title":"Adding Algorithms","text":"The EPIRK methods can only use Krylov approximation, and unlike the previous two they use the timestepping variant phiv_timestep. The timestepping method follows the convention of Neisen & Wright, and can be toggled to use adaptation by alg.adaptive_krylov.","category":"page"},{"location":"contributing/adding_algorithms/","page":"Adding Algorithms","title":"Adding Algorithms","text":"Although the exponential integrators (especially the in-place version) can seem complex, they share similar structures. The infrastructure for the existing exponential methods utilize the fact to reduce boilerplate code. In particular, the cache construction code in caches/linear_nonlinear_caches.jl and the initialize! method in perform_step/exponential_rk_perform_step.jl can be mostly automated and only perform_step! needs implementing.","category":"page"},{"location":"contributing/adding_algorithms/","page":"Adding Algorithms","title":"Adding Algorithms","text":"Finally, to construct tests for the new exponential algorithm, append the new algorithm to the corresponding algorithm class in test/linear_nonlinear_convergence_tests.jl and test/linear_nonlinear_krylov_tests.jl.","category":"page"},{"location":"contributing/adding_packages/#Adding-a-new-package-to-the-common-interface","page":"Adding a new package to the common interface","title":"Adding a new package to the common interface","text":"","category":"section"},{"location":"contributing/adding_packages/","page":"Adding a new package to the common interface","title":"Adding a new package to the common interface","text":"DiffEq's distributed infrastructure allows anyone to add new packages to the common interface. This set of the documentation explains how this is done. An example package is DASRK.jl whose full common interface bindings are contained in common.jl.","category":"page"},{"location":"contributing/adding_packages/#Defining-the-types","page":"Adding a new package to the common interface","title":"Defining the types","text":"","category":"section"},{"location":"contributing/adding_packages/","page":"Adding a new package to the common interface","title":"Adding a new package to the common interface","text":"You should start by defining a common supertype for all your algorithm types. DASKR has DAE algorithms, so it defines","category":"page"},{"location":"contributing/adding_packages/","page":"Adding a new package to the common interface","title":"Adding a new package to the common interface","text":"abstract type DASKRDAEAlgorithm{LinearSolver} <: DiffEqBase.AbstractDAEAlgorithm end","category":"page"},{"location":"contributing/adding_packages/","page":"Adding a new package to the common interface","title":"Adding a new package to the common interface","text":"that its algorithms are all AbstractDAEAlgorithms and gives them a possible type parameter as well. Then the concrete algorithms are specified. Special options (i.e. non-common interface options) for the algorithm go in this type. Here there is a choice for a linear solver internally, so we allow the user to set this:","category":"page"},{"location":"contributing/adding_packages/","page":"Adding a new package to the common interface","title":"Adding a new package to the common interface","text":"struct daskr{LinearSolver} <: DASKRDAEAlgorithm{LinearSolver} end\ndaskr(;linear_solver=:Dense) = daskr{linear_solver}()","category":"page"},{"location":"contributing/adding_packages/","page":"Adding a new package to the common interface","title":"Adding a new package to the common interface","text":"In many (most?) cases, no extra constructor is needed since there are no extra options.","category":"page"},{"location":"contributing/adding_packages/#Defining-the-overloads","page":"Adding a new package to the common interface","title":"Defining the overloads","text":"","category":"section"},{"location":"contributing/adding_packages/","page":"Adding a new package to the common interface","title":"Adding a new package to the common interface","text":"Now you need to add DiffEqBase. The package should reexport DiffEqBase.jl to make using it alone act naturally, and this is done by:","category":"page"},{"location":"contributing/adding_packages/","page":"Adding a new package to the common interface","title":"Adding a new package to the common interface","text":"using Reexport\n@reexport using DiffEqBase","category":"page"},{"location":"contributing/adding_packages/","page":"Adding a new package to the common interface","title":"Adding a new package to the common interface","text":"now we overload __solve from DiffEqBase.jl to act on our algorithm. Here's a possible signature:","category":"page"},{"location":"contributing/adding_packages/","page":"Adding a new package to the common interface","title":"Adding a new package to the common interface","text":"function DiffEqBase.__solve{uType,duType,tType,isinplace,LinearSolver}(\n    prob::AbstractDAEProblem{uType,duType,tType,isinplace},\n    alg::DASKRDAEAlgorithm{LinearSolver},\n    timeseries = [], ts = [], ks = [];\n\n    verbose=true,\n    callback = nothing, abstol = 1/10^6, reltol = 1/10^3,\n    saveat = Float64[], adaptive = true, maxiters = Int(1e5),\n    timeseries_errors = true, save_everystep = isempty(saveat), dense = save_everystep,\n    save_start = true, save_timeseries = nothing,\n    userdata = nothing,\n    kwargs...)","category":"page"},{"location":"contributing/adding_packages/","page":"Adding a new package to the common interface","title":"Adding a new package to the common interface","text":"Basically you just dispatch on your algorithm supertype (and refine the Problem choice as well so it errors on the wrong problem types), then list the common interface options. timeseries = [], ts = [], ks = []; are for pre-allocation of arrays, and this may change in the near future but you can use this to pre-allocate the t, u, and k arrays (k being internal steps if saved).","category":"page"},{"location":"contributing/adding_packages/#Defining-the-solution","page":"Adding a new package to the common interface","title":"Defining the solution","text":"","category":"section"},{"location":"contributing/adding_packages/","page":"Adding a new package to the common interface","title":"Adding a new package to the common interface","text":"In solve you do option handling and call your solver. At the end, you return the solution via:","category":"page"},{"location":"contributing/adding_packages/","page":"Adding a new package to the common interface","title":"Adding a new package to the common interface","text":"build_solution(prob,alg,ts,timeseries,\n               du = dures,\n               dense = dense,\n               timeseries_errors = timeseries_errors,\n               retcode = :Success)","category":"page"},{"location":"contributing/adding_packages/","page":"Adding a new package to the common interface","title":"Adding a new package to the common interface","text":"Giving du is only currently allowed for DAEs and is optional. The errors flags (timeseries_errors and dense_errors) are flags for allowing the solution to calculate errors which should be passed through the solve function if applicable. A proper retcode should be placed or it will default to :Default.","category":"page"},{"location":"contributing/ecosystem_overview/#Ecosystem-Overview","page":"Ecosystem Overview","title":"Ecosystem Overview","text":"","category":"section"},{"location":"contributing/ecosystem_overview/","page":"Ecosystem Overview","title":"Ecosystem Overview","text":"So you're looking to help out DifferentialEquations.jl? We'd be happy to have your help. It is recommended you first discuss with some of the developers on the Gitter channel to make sure that you're up-to-date with current developments.","category":"page"},{"location":"contributing/ecosystem_overview/#The-Common-Interface","page":"Ecosystem Overview","title":"The Common Interface","text":"","category":"section"},{"location":"contributing/ecosystem_overview/","page":"Ecosystem Overview","title":"Ecosystem Overview","text":"The DiffEq ecosystem is built around the common interface. This is the interface for the solvers:","category":"page"},{"location":"contributing/ecosystem_overview/","page":"Ecosystem Overview","title":"Ecosystem Overview","text":"__solve(prob,alg;kwargs...)\n__init(prob,alg;kwargs...)","category":"page"},{"location":"contributing/ecosystem_overview/","page":"Ecosystem Overview","title":"Ecosystem Overview","text":"and the standard methods for dealing with solutions. A higher level solve and init is given by DiffEqBase.jl for functional and distributional intputs. Users build problem types for solvers to act on, and add-on components which use the solution types for higher-level analysis like parameter estimation and sensitivity analysis.","category":"page"},{"location":"contributing/ecosystem_overview/","page":"Ecosystem Overview","title":"Ecosystem Overview","text":"One can add components at any of these levels to improve the functionality of the system as a whole.","category":"page"},{"location":"contributing/ecosystem_overview/#Organizational-Setup","page":"Ecosystem Overview","title":"Organizational Setup","text":"","category":"section"},{"location":"contributing/ecosystem_overview/","page":"Ecosystem Overview","title":"Ecosystem Overview","text":"JuliaDiffEq is setup in a distributed manner to allow developers to retain authoritative control and licensing for their own packages/algorithms, yet contribute to the greater ecosystem. This gives a way for researchers to target a wide audience of users, but not have to fully contribute to public packages or be restricted in licensing. At the center of the ecosystem is DiffEqBase which holds the Problem, Solution, and Algorithm types (the algorithms are defined in DiffEqBase to be accessible by the default_algorithm function. One can opt out of this). Then there's the component solvers, which includes the *DiffEq packages (OrdinaryDiffEq, StochasticDiffEq, etc.) which implement different methods for solve. Then there are the add-on packages, such as the DiffEq* packages (DiffEqParamEstim, DiffEqDevTools) which add functionality to the Problem+solve setup. Lastly, there's DifferentialEquations.jl which is a metapackage which holds all of these pieces together as one cohesive unit.","category":"page"},{"location":"contributing/ecosystem_overview/","page":"Ecosystem Overview","title":"Ecosystem Overview","text":"If one wants their package to officially join the ecosystem, it will need to be moved to the JuliaDiffEq organization so that maintenance can occur (but the core algorithms will only be managed by the package owners themselves). The Algorithm types can then be moved to DiffEqBase, and after testing the package will be added to the list packages exported by DifferentialEquations.jl and the corresponding documentation.","category":"page"},{"location":"internals/notes_on_algorithms/#Notes-on-Algorithms","page":"Notes on Algorithms","title":"Notes on Algorithms","text":"","category":"section"},{"location":"internals/notes_on_algorithms/","page":"Notes on Algorithms","title":"Notes on Algorithms","text":"This page is a supplemental page which details some facts about the chosen algorithms, why some I took the time to make optimized versions for, and for others why they were ignored.","category":"page"},{"location":"internals/notes_on_algorithms/#Explicit-Runge-Kutta-ODE-Algorithms","page":"Notes on Algorithms","title":"Explicit Runge-Kutta ODE Algorithms","text":"","category":"section"},{"location":"internals/notes_on_algorithms/","page":"Notes on Algorithms","title":"Notes on Algorithms","text":"From what I can tell, this is by far the most comprehensive comparison of Explicit Runge-Kutta ODE algorithms that you'll find.","category":"page"},{"location":"internals/notes_on_algorithms/#Implementations","page":"Notes on Algorithms","title":"Implementations","text":"","category":"section"},{"location":"internals/notes_on_algorithms/","page":"Notes on Algorithms","title":"Notes on Algorithms","text":"The different implementations have been benchmarked against each other. The efficiency was calculated by weighing both the time and error on classic test problems. To make clear distinctions, solver options were tweaked to many different settings, including:","category":"page"},{"location":"internals/notes_on_algorithms/","page":"Notes on Algorithms","title":"Notes on Algorithms","text":"Matching errors\nMatching runtimes\nMatching settings\nLow/High tolerance","category":"page"},{"location":"internals/notes_on_algorithms/","page":"Notes on Algorithms","title":"Notes on Algorithms","text":"The DifferentialEquations.jl implementations of the explicit Runge-Kutta solvers are by a good margin the most efficient implementations of the given algorithms. They utilize many extra tricks, nice caching, and threading if available, to vastly outperform the other methods in terms of efficiency (even with threading disabled). :DP5 performs much better than :dopri5, which vastly outperform ode45 (whose stepsize algorithm tends to have issues on some quasi-stiff problems). :DP8 performs better than dop853 in some cases, worse in others. Both vastly outperform ode78.","category":"page"},{"location":"internals/notes_on_algorithms/","page":"Notes on Algorithms","title":"Notes on Algorithms","text":"For this reason, the DifferentialEquations.jl non-stiff algorithms are the recommended implementations. ODEInterface non-stiff algorithms are only recommended for historical purposes (i.e. to match previous results) or to try dop853 on a problem (work is being to find out what the difference is and squash the competition here!). The ODE.jl algorithms are not recommended for any serious use (the package is essentially deprecated: it's slow, gets high error, the timestepping algorithm is not robust, and doesn't implement many methods).","category":"page"},{"location":"internals/notes_on_algorithms/#Order-4","page":"Notes on Algorithms","title":"Order 4-","text":"","category":"section"},{"location":"internals/notes_on_algorithms/","page":"Notes on Algorithms","title":"Notes on Algorithms","text":"At this stage, coefficient of the truncation error seems to win out, or you are willing to live with low tolerance anyways. Thus Bogacki-Shampine is the clear winner in this category because at order 2/3 with FASL it has minimal numbers of function evaluations but also is stable enough to step as needed. All other methods don't compare because of the FASL property boosting the order and thus the stability (for low orders, it pretty much holds that higher order = higher stability (for optimal number of steps), which is not true as we go higher), making it more stable and have less error for lower numbers of function evaluations than the others in this category.","category":"page"},{"location":"internals/notes_on_algorithms/#Order-5","page":"Notes on Algorithms","title":"Order 5","text":"","category":"section"},{"location":"internals/notes_on_algorithms/","page":"Notes on Algorithms","title":"Notes on Algorithms","text":"[Note that for all of these Peter Stone's modifications do not seem to be helpful since, although they lower the truncation error, they also modify the stability region in ways that can be worrisome (mostly they shrink the stability in the complex axis near the origin, making the problems not as suitable for a \"general purpose default\" like one would hope with a 4/5 solver)]","category":"page"},{"location":"internals/notes_on_algorithms/","page":"Notes on Algorithms","title":"Notes on Algorithms","text":"The \"clear choice\" is the Dormand-Prince 4/5 pair. This is the pair which is used by default as ode45 in MATLAB, and serves similar functions in scipy, ODE.jl, etc. The golden standard implementation is Hairer's DOPRI5 (offered by ODEInterface.jl). After optimizations, DifferentialEquations.jl's native DP5 solver is much more efficient (between 4x-400x) than DOPRI5's, with various design choices factoring into this (which are documented in the benchmarks). This is pre-threading, and within method threading will likely be at least doubled or tripled when threading is enabled. Thus it's clear that the reference implementation to try other methods against is the DifferentialEquations.jl DP5 method.","category":"page"},{"location":"internals/notes_on_algorithms/","page":"Notes on Algorithms","title":"Notes on Algorithms","text":"It's obvious that anything before Dormand-Prince 4/5's pair is simply not as good because of the optimizations on the local truncation error coefficient and the fact that FASL schemes essentially have one less function evaluation. So the previous algorithms were implemented as tableaus for the historical reasons but dealt with no further. These methods include the Runge, Cassity, Butcher, Fehlburg, Lawson, Luther and Konen, and Kutta schemes.","category":"page"},{"location":"internals/notes_on_algorithms/","page":"Notes on Algorithms","title":"Notes on Algorithms","text":"The next set of schemes are the Papakostas-Papageorgiou schemes. The problem is that they don't really get the much lower on the error than DP5, but also have wacky stability near the origin.","category":"page"},{"location":"internals/notes_on_algorithms/","page":"Notes on Algorithms","title":"Notes on Algorithms","text":"Tsitouras's looks to be a good match against DP5 as a 6-stage scheme to take on DP5. Its stability is similar to DP5 but its first error term is an order of magnitude smaller. More tests will likely determine that this is much better than DP5 in accordance with his paper.","category":"page"},{"location":"internals/notes_on_algorithms/","page":"Notes on Algorithms","title":"Notes on Algorithms","text":"Lastly, there are the 7-stage schemes. The more recent one is due to Sharp and Smart, but I am ignoring this because its error term is almost an order of magnitude larger than the BS pair, and its stability region is wonky near the origin. Its only plus over the BS pair is that it has a slightly larger stability in the real axis, which is not important when paired with adaptive stepping and for use on non-stiff problems.","category":"page"},{"location":"internals/notes_on_algorithms/","page":"Notes on Algorithms","title":"Notes on Algorithms","text":"That leaves us with the Bogacki-Shampine pair. This pair gets more than an order of magnitude lower truncation error, enhanced complex stability, and two error estimators to make it more robust. In fact, this is the default which is chosen in Mathematica. Its downside is that since it is an 8-stage scheme, it requires an additional function evaluation.","category":"page"},{"location":"internals/notes_on_algorithms/","page":"Notes on Algorithms","title":"Notes on Algorithms","text":"Further tests will likely narrow this down to Tsitouras vs Bogacki-Shampine. Who will come out on top? Who knows.","category":"page"},{"location":"internals/notes_on_algorithms/#Order-6","page":"Notes on Algorithms","title":"Order 6","text":"","category":"section"},{"location":"internals/notes_on_algorithms/","page":"Notes on Algorithms","title":"Notes on Algorithms","text":"Sharp-Verner has bad complex stability near the origin. I don't like any of the Peter Stone modifications here. Butcher and Chummund methods have stability issues near the origin as well. Huta's method has too high of an error coefficient. Verner's 1991 has bad complex stability. Same as the most robust. The Verner \"most efficient\" has really good stability and error coefficient. In fact, nothing is even close except for Tsitouras' method. The DP method is two orders of magnitude higher in error coefficient than Verner. The Luther methods have too much error. Same as Tsitouras-Papakostas and  M. Tanaka, K. Kasuga, S. Yamashita and H. Yazaki.","category":"page"},{"location":"internals/notes_on_algorithms/","page":"Notes on Algorithms","title":"Notes on Algorithms","text":"Without a doubt the winner is the Verner \"most efficient\".","category":"page"},{"location":"internals/notes_on_algorithms/#Order-7","page":"Notes on Algorithms","title":"Order 7","text":"","category":"section"},{"location":"internals/notes_on_algorithms/","page":"Notes on Algorithms","title":"Notes on Algorithms","text":"The Enright-Verner and other Verner methods all have stability issues near the origin in the complex plane and higher error coefficients. Sharp and Smart have higher error coefficients. Peter Stone's methods all have higher error. It's very clear that the best here is the Tanaka-Yamashita (efficient, not the stable) method by far.","category":"page"},{"location":"internals/notes_on_algorithms/#Order-8","page":"Notes on Algorithms","title":"Order 8","text":"","category":"section"},{"location":"internals/notes_on_algorithms/","page":"Notes on Algorithms","title":"Notes on Algorithms","text":"The Cooper-Verner methods do not have an error estimate and so no adaptive timestepping can be done. This is a deal-breaker. Going into this one would think that the clear winner would be Dormand-Prince 8. But that's not the case. However, that's comparing the classical 1981 DP87. Notice that the code for Dop853 is based off of the 1989 paper which has different coefficients (and currently I have no analysis for this).","category":"page"},{"location":"internals/notes_on_algorithms/","page":"Notes on Algorithms","title":"Notes on Algorithms","text":"The other methods include Verner's Maple dverk78 which is bested in both stability and error coefficient by Enright-Verner which is bested by Tsitouras-Papakostas.","category":"page"},{"location":"internals/notes_on_algorithms/","page":"Notes on Algorithms","title":"Notes on Algorithms","text":"Thus the final showdown is between DP853 vs the Tsitouras-Papakostas pair.","category":"page"},{"location":"internals/notes_on_algorithms/#Order-9","page":"Notes on Algorithms","title":"Order 9","text":"","category":"section"},{"location":"internals/notes_on_algorithms/","page":"Notes on Algorithms","title":"Notes on Algorithms","text":"The Tsitouras scheme and the Sharp scheme have funky stability near the origin. Verner's schemes are much safer, and with similar error. They clearly dominate this category.","category":"page"},{"location":"internals/notes_on_algorithms/#Order-10","page":"Notes on Algorithms","title":"Order 10","text":"","category":"section"},{"location":"internals/notes_on_algorithms/","page":"Notes on Algorithms","title":"Notes on Algorithms","text":"Curtis' scheme has more function evaluations than needed, and Peter Stone's modification reduces the truncation error by a lot but adds three more function evaluations. Thus Hairer's 17 stage scheme (whose error and stability is similar to Curtis') is clearly better. Once again Peter Stone's modification adds three steps but does not reduce the truncation error here, so the unmodified version does better.","category":"page"},{"location":"internals/notes_on_algorithms/","page":"Notes on Algorithms","title":"Notes on Algorithms","text":"Tom Baker's method increases the stability region to something which is more than necessary but adds 4 function evaluations to do so (without lowering the error very much). Ono's scheme minimizes the error more than Hairer's here, with all else being basically the same. The Peter Stone methods add a lot of function evaluations (5+) and so they would only be useful in the case where the function evaluations are quick yet you still want really small error. Even then I'm not convinced they are better than the other methods, or better than the higher order methods which use less steps. The stability is only okay.","category":"page"},{"location":"internals/notes_on_algorithms/","page":"Notes on Algorithms","title":"Notes on Algorithms","text":"The Feagin scheme is fine, but with more error and less stability than the Hairer scheme. Thus it seems clear that Hairer's method dominates this category. However, that's only because it does not include an error estimate. Feagin's scheme is close in error and stability, but includes an error estimate which can be used for adaptivity, making it the choice in this category.","category":"page"},{"location":"internals/notes_on_algorithms/#Order-11","page":"Notes on Algorithms","title":"Order 11","text":"","category":"section"},{"location":"internals/notes_on_algorithms/","page":"Notes on Algorithms","title":"Notes on Algorithms","text":"The order 11 schemes are due to Tom Baker at the University of Teeside. They have a nice sparsity pattern and receive slightly lower truncation error coefficents than the Feagin, but Feagin's dominates by being \"almost order 13\" anyways so while a nice try the order 11 scheme is likely overwhelmed in any case where it would be useful.","category":"page"},{"location":"internals/notes_on_algorithms/#Order-12","page":"Notes on Algorithms","title":"Order 12","text":"","category":"section"},{"location":"internals/notes_on_algorithms/","page":"Notes on Algorithms","title":"Notes on Algorithms","text":"Here there are the Feagin schemes and Ono's scheme. Ono's scheme gets horrible stability with more error and so it's not in the running. Peter Stone's modifications do not make a substantive change, and where they do they get rid of the nice property that the Feagin 12 method satisfies many of the higher order conditions as well, making it look even higher order on some problems. Thus the standard Feagin 12 seems to win out in this category.","category":"page"},{"location":"internals/notes_on_algorithms/#Order-14","page":"Notes on Algorithms","title":"Order 14","text":"","category":"section"},{"location":"internals/notes_on_algorithms/","page":"Notes on Algorithms","title":"Notes on Algorithms","text":"In this category there is just the Feagin. Peter Stone's modification barely changes anything in the analysis so I did not even attempt it.","category":"page"},{"location":"alg_dev/benchmarks/#Benchmark-Suite","page":"Benchmark Suite","title":"Benchmark Suite","text":"","category":"section"},{"location":"alg_dev/benchmarks/","page":"Benchmark Suite","title":"Benchmark Suite","text":"DifferentialEquations.jl provides a benchmarking suite to be able to test the difference in error, speed, and efficiency between algorithms. DifferentialEquations.jl includes current benchmarking notebooks to help users understand the performance of the methods. These benchmarking notebooks use the included benchmarking suite. There are two parts to the benchmarking suite: shootouts and work-precision. The Shootout tests methods head-to-head for timing and error on the same problem. A WorkPrecision draws a work-precision diagram for the algorithms in question on the chosen problem.","category":"page"},{"location":"alg_dev/benchmarks/#Rendered-Benchmarks","page":"Benchmark Suite","title":"Rendered Benchmarks","text":"","category":"section"},{"location":"alg_dev/benchmarks/","page":"Benchmark Suite","title":"Benchmark Suite","text":"The rendered SciML Benchmarks can be found at benchmarks.sciml.ai. The source code for the benchmarks can be found at https://github.com/SciML/SciMLBenchmarks.jl.","category":"page"},{"location":"alg_dev/benchmarks/#Shootout","page":"Benchmark Suite","title":"Shootout","text":"","category":"section"},{"location":"alg_dev/benchmarks/","page":"Benchmark Suite","title":"Benchmark Suite","text":"A shootout is where you compare between algorithms. For example, to see how different Runge-Kutta algorithms fair against each other, one can define a setup which is a dictionary of Symbols to Any, where the symbol is the keyword argument. Then you call Shootout on that setup. The code is as follows:","category":"page"},{"location":"alg_dev/benchmarks/","page":"Benchmark Suite","title":"Benchmark Suite","text":"using OrdinaryDiffEq,DiffEqProblemLibrary.ODEProblemLibrary,DiffEqDevTools,ODE,ODEInterface,ODEInterfaceDiffEq\n\nODEProblemLibrary.importodeproblems()\nprob = ODEProblemLibrary.prob_ode_2Dlinear\nsetups = [Dict(:alg=>DP5())\n          Dict(:abstol=>1e-3,:reltol=>1e-6,:alg=>ode45()) # Fix ODE to be normal\n          Dict(:alg=>dopri5())]\nnames = [\"DifferentialEquations\";\"ODE\";\"ODEInterface\"]\nshoot = Shootout(prob,setups;dt=1/2^(10),names=names)","category":"page"},{"location":"alg_dev/benchmarks/","page":"Benchmark Suite","title":"Benchmark Suite","text":"Note that keyword arguments applied to Shootout are applied to every run, so in this example every run has the same starting timestep.  Here we explicitly chose names. If you don't, then the algorithm name is the default. This returns a Shootout type which holds the times it took for each algorithm and the errors. Using these, it calculates the efficiency defined as 1/(error*time), i.e. if the error is low or the run was quick then it's efficient. print(shoot) will show all of this information, and plot(shoot) will show the efficiencies of the algorithms in comparison to each other.","category":"page"},{"location":"alg_dev/benchmarks/","page":"Benchmark Suite","title":"Benchmark Suite","text":"For every benchmark function there is a special keyword numruns which controls the number of runs used in the time estimate. To be more precise, these functions by default run the algorithm 20 times on the problem and take the average time. This amount can be increased and decreased as needed.","category":"page"},{"location":"alg_dev/benchmarks/","page":"Benchmark Suite","title":"Benchmark Suite","text":"The keyword appxsol allows for specifying a reference against which the error is computed. The method of error computation can be specified by the keyword error_estimate with values :L2 for the L2 error over the solution time interval, :l2 calculates the l2 error at the actual steps and the default :final only compares the endpoints.","category":"page"},{"location":"alg_dev/benchmarks/","page":"Benchmark Suite","title":"Benchmark Suite","text":"A ShootoutSet is a where you define a vector of probs and tspans and run a shootout on each of these values.","category":"page"},{"location":"alg_dev/benchmarks/#WorkPrecision","page":"Benchmark Suite","title":"WorkPrecision","text":"","category":"section"},{"location":"alg_dev/benchmarks/","page":"Benchmark Suite","title":"Benchmark Suite","text":"A WorkPrecision calculates the necessary componnets of a work-precision plot. This shows how time scales with the user chosen tolerances on a given problem. To make a WorkPrecision, you give it a vector of absolute and relative tolerances:","category":"page"},{"location":"alg_dev/benchmarks/","page":"Benchmark Suite","title":"Benchmark Suite","text":"abstols = 1 ./10 .^ (3:10)\nreltols = 1 ./10 .^ (3:10)\nwp = WorkPrecision(prob,DP5(),abstols,reltols;name=\"Dormand-Prince 4/5\")","category":"page"},{"location":"alg_dev/benchmarks/","page":"Benchmark Suite","title":"Benchmark Suite","text":"If we want to plot many WorkPrecisions together in order to compare between algorithms, you can make a WorkPrecisionSet. To do so, you pass the setups into the function as well:","category":"page"},{"location":"alg_dev/benchmarks/","page":"Benchmark Suite","title":"Benchmark Suite","text":"wp_set = WorkPrecisionSet(prob,tspan,abstols,reltols,setups;numruns=2)\nsetups = [Dict(:alg=>RK4());Dict(:alg=>Euler());Dict(:alg=>BS3());\n          Dict(:alg=>Midpoint());Dict(:alg=>BS5());Dict(:alg=>DP5())]    \nwp_set = WorkPrecisionSet(prob,abstols,reltols,setups;dt=1/2^4,numruns=2)","category":"page"},{"location":"alg_dev/benchmarks/","page":"Benchmark Suite","title":"Benchmark Suite","text":"Both of these types have a plot recipe to produce a work-precision diagram, and a print which will show some relevant information.","category":"page"},{"location":"#SciML-Scientific-Machine-Learning-Developer-Documentation","page":"Home","title":"SciML Scientific Machine Learning Developer Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This is the developer documentation and Contributor's Guide for the SciML ecosystem. It explains the common interface and some the package internals to help developers contribute.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you have any questions, or just want to chat about solvers/using the package, please feel free to use the Gitter channel. For bug reports, feature requests, etc., please submit an issue.","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The SciML ecosystem is built around the common interface. The common interface is a type-based interface where users define problems as a type, and solvers plug into the ecosystem by defining an algorithm to give a new dispatch to","category":"page"},{"location":"","page":"Home","title":"Home","text":"__solve(prob,alg;kwargs...)\n__init(prob,alg;kwargs...)","category":"page"},{"location":"","page":"Home","title":"Home","text":"There is a top level solve and init function which is in DiffEqBase.jl that handles distribution and function input (along with extra warnings) before sending the problems to the packages.","category":"page"},{"location":"","page":"Home","title":"Home","text":"There is then an ecosystem of add-on components which use the common solver interface to add analysis tools for differential equations.","category":"page"},{"location":"#Contributing-to-the-Ecosystem","page":"Home","title":"Contributing to the Ecosystem","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"There are many ways to help the ecosystem. One way you can contribute is to give pull requests (PRs) to existing packages. Another way to contribute is to add your own package to the ecosystem. Adding your own package to the ecosystem allows you to keep executive control and licensing over your methods, but allows users of DifferentialEquations.jl to use your methods via the common interface, and makes your package compatible with the add-on tools (sensitivity analysis, parameter estimation, etc). Note that, in order for the method to be used as a default, one is required to move their package to the SciML organization so that way common maintenance (such as fixing deprication warnings, updating tests to newer versions, and emergency fixes / disabling) can be allowed by SciML members. However, the lead developer of the package maintains administrative control, and thus any change to the core algorithms by other SciML members will only be given through PRs.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Even if you don't have the time to contribute new solver algorithms or add-on tools, there's always ways to help! Improved plot recipes and new series recipes are always nice to add more default plots. It is always helpful to have benchmarks between different algorithms to see \"which is best\". Adding examples IJulia notebooks to DiffEqTutorials.jl is a good way to share knowledge about DifferentialEquations.jl. Also, please feel free to comb through the solvers and look for ways to make them more efficient. Lastly, the documentation could always use improvements. If you have any questions on how to help, just ask them in the Gitter!","category":"page"},{"location":"#Code-of-Conduct","page":"Home","title":"Code of Conduct","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"All contributors must adhere to the NumFOCUS Code of Conduct.  Treat everyone with respect. Failure to comply will result in individuals being banned from the community. ","category":"page"},{"location":"#Contributor-Guide","page":"Home","title":"Contributor Guide","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n  \"contributing/ecosystem_overview.md\",\n  \"contributing/adding_packages.md\",\n  \"contributing/adding_algorithms.md\",\n  \"contributing/defining_problems.md\",\n  \"contributing/diffeq_internals.md\",\n  \"contributing/type_traits.md\"\n]\nDepth = 2","category":"page"},{"location":"#Algorithm-Development-Tools","page":"Home","title":"Algorithm Development Tools","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The following algorithm development tools are provided by DiffEqDevTools.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n  \"alg_dev/test_problems.md\",\n  \"alg_dev/convergence.md\",\n  \"alg_dev/benchmarks.md\"\n]\nDepth = 2","category":"page"},{"location":"#Internal-Documentation","page":"Home","title":"Internal Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n  \"internals/fem_tools.md\",\n  \"internals/notes_on_algorithms.md\",\n  \"internals/tableaus.md\"\n]\nDepth = 2","category":"page"},{"location":"#Reproducibility","page":"Home","title":"Reproducibility","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"<details><summary>The documentation of this SciML package was built using these direct dependencies,</summary>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg # hide\nPkg.status() # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</details>","category":"page"},{"location":"","page":"Home","title":"Home","text":"<details><summary>and using this machine and Julia version.</summary>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using InteractiveUtils # hide\nversioninfo() # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</details>","category":"page"},{"location":"","page":"Home","title":"Home","text":"<details><summary>A more complete overview of all dependencies and their versions is also provided.</summary>","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg # hide\nPkg.status(;mode = PKGMODE_MANIFEST) # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"</details>","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can also download the \n<a href=\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"using TOML\nversion = TOML.parse(read(\"../../Project.toml\",String))[\"version\"]\nname = TOML.parse(read(\"../../Project.toml\",String))[\"name\"]\nlink = \"https://github.com/SciML/\"*name*\".jl/tree/gh-pages/v\"*version*\"/assets/Manifest.toml\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"\">manifest</a> file and the\n<a href=\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"using TOML\nversion = TOML.parse(read(\"../../Project.toml\",String))[\"version\"]\nname = TOML.parse(read(\"../../Project.toml\",String))[\"name\"]\nlink = \"https://github.com/SciML/\"*name*\".jl/tree/gh-pages/v\"*version*\"/assets/Project.toml\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"\">project</a> file.","category":"page"},{"location":"contributing/type_traits/#Type-Traits","page":"Type Traits","title":"Type Traits","text":"","category":"section"},{"location":"contributing/type_traits/","page":"Type Traits","title":"Type Traits","text":"Many of the DiffEqBase abstract types have associated traits. These can be used to check compatibility and apply separate code paths. For example, a parameter estimation algorithm can set the default for using autodifferentiation by checking if the algorithm is compatible with autodifferentiation.","category":"page"},{"location":"contributing/type_traits/","page":"Type Traits","title":"Type Traits","text":"Below are the abstract types along with the associated trait functions. These are listed as:","category":"page"},{"location":"contributing/type_traits/","page":"Type Traits","title":"Type Traits","text":"f(x)","category":"page"},{"location":"contributing/type_traits/","page":"Type Traits","title":"Type Traits","text":"where f is the trait function and x is the any type which subtypes the abstract type.","category":"page"},{"location":"contributing/type_traits/#AbstractODEProblem","page":"Type Traits","title":"AbstractODEProblem","text":"","category":"section"},{"location":"contributing/type_traits/","page":"Type Traits","title":"Type Traits","text":"isinplace : Returns true if the problem uses in-place functions","category":"page"},{"location":"contributing/type_traits/#AbstractRODEProblem","page":"Type Traits","title":"AbstractRODEProblem","text":"","category":"section"},{"location":"contributing/type_traits/","page":"Type Traits","title":"Type Traits","text":"is_diagonal_noise : Returns true if the noise is diagonal.","category":"page"},{"location":"contributing/type_traits/#DEAlgorithm","page":"Type Traits","title":"DEAlgorithm","text":"","category":"section"},{"location":"contributing/type_traits/","page":"Type Traits","title":"Type Traits","text":"isautodifferentiable : Returns true if the algorithm is autodifferentiable.","category":"page"}]
}

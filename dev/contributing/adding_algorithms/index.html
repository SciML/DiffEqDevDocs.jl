<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Adding Algorithms ¬∑ SciML Developer Documentation</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-90474609-3"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-90474609-3', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://docs.sciml.ai/DiffEqDevDocs/stable/contributing/adding_algorithms/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="SciML Developer Documentation logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">SciML Developer Documentation</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Contributor Guide</span><ul><li><a class="tocitem" href="../ecosystem_overview/">Ecosystem Overview</a></li><li><a class="tocitem" href="../adding_packages/">Adding a new package to the common interface</a></li><li class="is-active"><a class="tocitem" href>Adding Algorithms</a><ul class="internal"><li><a class="tocitem" href="#Adding-new-algorithms-to-OrdinaryDiffEq"><span>Adding new algorithms to OrdinaryDiffEq</span></a></li></ul></li><li><a class="tocitem" href="../defining_problems/">Developing A New Problem</a></li><li><a class="tocitem" href="../diffeq_internals/">The DiffEq Internals</a></li><li><a class="tocitem" href="../type_traits/">Type Traits</a></li></ul></li><li><span class="tocitem">Algorithm Development Tools</span><ul><li><a class="tocitem" href="../../alg_dev/test_problems/">Test Problems</a></li><li><a class="tocitem" href="../../alg_dev/convergence/">Convergence Simulations</a></li><li><a class="tocitem" href="../../alg_dev/benchmarks/">Benchmark Suite</a></li></ul></li><li><span class="tocitem">Internal Documentation</span><ul><li><a class="tocitem" href="../../internals/notes_on_algorithms/">Notes on Algorithms</a></li><li><a class="tocitem" href="../../internals/tableaus/">ODE Tableaus</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Contributor Guide</a></li><li class="is-active"><a href>Adding Algorithms</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Adding Algorithms</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SciML/DiffEqDevDocs.jl/blob/master/docs/src/contributing/adding_algorithms.md" title="Edit on GitHub"><span class="docs-icon fab">ÔÇõ</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Adding-Algorithms"><a class="docs-heading-anchor" href="#Adding-Algorithms">Adding Algorithms</a><a id="Adding-Algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-Algorithms" title="Permalink"></a></h1><p>New algorithms can either be added by extending one of the current solver (or add-on packages), or by contributing a new package to the organization. If it&#39;s a new problem (a new PDE, a new type of differential equation, a new subclass of problems for which special methods exist, etc.) then the problem and solution types should be added to <code>DiffEqBase</code> first.</p><p>After the problem and solutions are defined, the <code>__solve</code> method should be implemented. It should take in keyword arguments which match the common interface (implement &quot;as many as possible&quot;). One should note and document the amount of compatibility with the common interface and Julia-defined types. After that, testing should be done using <code>DiffEqDevTools</code>. Convergence tests and benchmarks should be included to show the effectiveness of the algorithm and the correctness. Do not worry if the algorithm is not &quot;effective&quot;: the implementation can improve over time and some algorithms are useful just for the comparison they give!</p><p>After some development, one may want to document the algorithm in DiffEqBenchmarks and DiffEqTutorials.</p><h2 id="Adding-new-algorithms-to-OrdinaryDiffEq"><a class="docs-heading-anchor" href="#Adding-new-algorithms-to-OrdinaryDiffEq">Adding new algorithms to OrdinaryDiffEq</a><a id="Adding-new-algorithms-to-OrdinaryDiffEq-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-new-algorithms-to-OrdinaryDiffEq" title="Permalink"></a></h2><p>This recipe has been used to add the strong stability preserving Runge-Kutta methods <code>SSPRK22</code>, <code>SSPRK33</code>, and <code>SSPRK104</code> to <code>OrdinaryDiffEq</code>. <code>SSPRK22</code> will be used as an example.</p><ul><li>To create a new solver, two (three) types have to be created. The first is the algorithm <code>SSPRK22</code> used for dispatch, the other ones are the corresponding caches <code>SSPRK22Cache</code> (for inplace updates) and <code>SSPRK22ConstantCache</code>.</li><li>The algorithm is defined in <code>algorithms.jl</code> as <code>struct SSPRK22 &lt;: OrdinaryDiffEqAlgorithm end</code>. Although it does not have the FSAL property, this is set to true since the derivative at the start and the end of the interval are used for the Hermite interpolation, and so this is FSAL&#39;d so that way only a single extra function evaluation occurs over the whole integration. This is done in <code>alg_utils.jl</code> via <code>isfsal(alg::SSPRK22) = true</code>. Additionally, the order is set in the same file via <code>alg_order(alg::SSPRK22) = 2</code>.</li><li>The algorithm <code>SSPRK22</code> is exported in <code>OrdinaryDiffEq.jl</code>.</li><li>In <code>caches.jl</code>, the two cache types <code>SSPRK22Cache</code> (for inplace updates) and <code>SSPRK22ConstantCache</code> are defined, similarly to the other ones. Note: <code>u_cache(c::SSPRK22Cache) = ()</code> and <code>du_cache(c::SSPRK22Cache) = (c.k,c.du,c.fsalfirst)</code> return the parts of the modifiable cache that are changed if the size of the ODE changes.</li><li>A new file <code>perform_step/ssprk_perform_step.jl</code> has been used for the new implementations. For both types of caches, the functions <code>initialize!</code> and <code>perform_step!</code> are defined there.</li><li>Finally, tests are added. A new file <code>test/ode/ode_ssprk_tests.jl</code> is created and included in <code>tests/runtests.jl</code> via <code>@time @testset &quot;SSPRK Tests&quot; begin include(&quot;ode/ode_ssprk_tests.jl&quot;) end</code>.</li><li>Additionally, regression tests for the dense output are added in <code>test/ode/ode_dense_tests.jl</code>.</li></ul><p>For more details, refer to https://github.com/JuliaDiffEq/OrdinaryDiffEq.jl/pull/40</p><h3 id="Self-Contained-Example"><a class="docs-heading-anchor" href="#Self-Contained-Example">Self-Contained Example</a><a id="Self-Contained-Example-1"></a><a class="docs-heading-anchor-permalink" href="#Self-Contained-Example" title="Permalink"></a></h3><pre><code class="language-julia hljs">using OrdinaryDiffEq
import OrdinaryDiffEq:
                       OrdinaryDiffEqAlgorithm, OrdinaryDiffEqMutableCache,
                       OrdinaryDiffEqConstantCache,
                       alg_order, alg_cache, initialize!, perform_step!, trivial_limiter!,
                       constvalue,
                       @muladd, @unpack, @cache, @..

struct RK_ALG{StageLimiter, StepLimiter} &lt;: OrdinaryDiffEq.OrdinaryDiffEqAlgorithm
    stage_limiter!::StageLimiter
    step_limiter!::StepLimiter
end
RK_ALG(stage_limiter! = trivial_limiter!) = RK_ALG(stage_limiter!, trivial_limiter!)
export RK_ALG
alg_order(alg::RK_ALG) = 3

@cache struct RK_ALGCache{uType, rateType, StageLimiter, StepLimiter, TabType} &lt;:
              OrdinaryDiffEqMutableCache
    u::uType
    uprev::uType
    k::rateType
    tmp::uType
    u‚ÇÇ::uType
    fsalfirst::rateType
    stage_limiter!::StageLimiter
    step_limiter!::StepLimiter
    tab::TabType
end

struct RK_ALGConstantCache{T, T2} &lt;: OrdinaryDiffEqConstantCache
    Œ±40::T
    Œ±41::T
    Œ±43::T
    Œ±62::T
    Œ±65::T
    Œ≤10::T
    Œ≤21::T
    Œ≤32::T
    Œ≤43::T
    Œ≤54::T
    Œ≤65::T
    c1::T2
    c2::T2
    c3::T2
    c4::T2
    c5::T2
end

function RK_ALGConstantCache(T, T2)
    Œ±40 = T(0.476769811285196)
    Œ±41 = T(0.098511733286064)
    Œ±43 = T(0.424718455428740)
    Œ±62 = T(0.155221702560091)
    Œ±65 = T(0.844778297439909)
    Œ≤10 = T(0.284220721334261)
    Œ≤21 = T(0.284220721334261)
    Œ≤32 = T(0.284220721334261)
    Œ≤43 = T(0.120713785765930)
    Œ≤54 = T(0.284220721334261)
    Œ≤65 = T(0.240103497065900)
    c1 = T2(0.284220721334261)
    c2 = T2(0.568441442668522)
    c3 = T2(0.852662164002783)
    c4 = T2(0.510854218958172)
    c5 = T2(0.795074940292433)

    RK_ALGConstantCache(
        Œ±40, Œ±41, Œ±43, Œ±62, Œ±65, Œ≤10, Œ≤21, Œ≤32, Œ≤43, Œ≤54, Œ≤65, c1, c2, c3, c4, c5)
end

function alg_cache(alg::RK_ALG, u, rate_prototype, uEltypeNoUnits, uBottomEltypeNoUnits,
        tTypeNoUnits, uprev, uprev2, f, t, dt, reltol, p, calck, ::Val{true})
    tmp = similar(u)
    u‚ÇÇ = similar(u)
    k = zero(rate_prototype)
    fsalfirst = zero(rate_prototype)
    tab = RK_ALGConstantCache(real(uBottomEltypeNoUnits), real(tTypeNoUnits))
    RK_ALGCache(u, uprev, k, tmp, u‚ÇÇ, fsalfirst, alg.stage_limiter!, alg.step_limiter!, tab)
end

function alg_cache(alg::RK_ALG, u, rate_prototype, uEltypeNoUnits, uBottomEltypeNoUnits,
        tTypeNoUnits, uprev, uprev2, f, t, dt, reltol, p, calck, ::Val{false})
    RK_ALGConstantCache(real(uBottomEltypeNoUnits), real(tTypeNoUnits))
end

function initialize!(integrator, cache::RK_ALGConstantCache)
    integrator.fsalfirst = integrator.f(integrator.uprev, integrator.p, integrator.t) # Pre-start fsal
    integrator.destats.nf += 1
    integrator.kshortsize = 1
    integrator.k = typeof(integrator.k)(undef, integrator.kshortsize)

    # Avoid undefined entries if k is an array of arrays
    integrator.fsallast = zero(integrator.fsalfirst)
    integrator.k[1] = integrator.fsalfirst
end

@muladd function perform_step!(integrator, cache::RK_ALGConstantCache, repeat_step = false)
    @unpack t, dt, uprev, u, f, p = integrator
    @unpack Œ±40, Œ±41, Œ±43, Œ±62, Œ±65, Œ≤10, Œ≤21, Œ≤32, Œ≤43, Œ≤54, Œ≤65, c1, c2, c3, c4, c5 = cache

    # u1 -&gt; stored as u
    u = uprev + Œ≤10 * dt * integrator.fsalfirst
    k = f(u, p, t + c1 * dt)
    # u2
    u‚ÇÇ = u + Œ≤21 * dt * k
    k = f(u‚ÇÇ, p, t + c2 * dt)
    # u3
    tmp = u‚ÇÇ + Œ≤32 * dt * k
    k = f(tmp, p, t + c3 * dt)
    # u4
    tmp = Œ±40 * uprev + Œ±41 * u + Œ±43 * tmp + Œ≤43 * dt * k
    k = f(tmp, p, t + c4 * dt)
    # u5
    tmp = tmp + Œ≤54 * dt * k
    k = f(tmp, p, t + c5 * dt)
    # u
    u = Œ±62 * u‚ÇÇ + Œ±65 * tmp + Œ≤65 * dt * k

    integrator.fsallast = f(u, p, t + dt) # For interpolation, then FSAL&#39;d
    integrator.destats.nf += 6
    integrator.k[1] = integrator.fsalfirst
    integrator.u = u
end

function initialize!(integrator, cache::RK_ALGCache)
    @unpack k, fsalfirst = cache
    integrator.fsalfirst = fsalfirst
    integrator.fsallast = k
    integrator.kshortsize = 1
    resize!(integrator.k, integrator.kshortsize)
    integrator.k[1] = integrator.fsalfirst
    integrator.f(integrator.fsalfirst, integrator.uprev, integrator.p, integrator.t) # FSAL for interpolation
    integrator.destats.nf += 1
end

@muladd function perform_step!(integrator, cache::RK_ALGCache, repeat_step = false)
    @unpack t, dt, uprev, u, f, p = integrator
    @unpack k, tmp, u‚ÇÇ, fsalfirst, stage_limiter!, step_limiter! = cache
    @unpack Œ±40, Œ±41, Œ±43, Œ±62, Œ±65, Œ≤10, Œ≤21, Œ≤32, Œ≤43, Œ≤54, Œ≤65, c1, c2, c3, c4, c5 = cache.tab

    # u1 -&gt; stored as u
    @.. u = uprev + Œ≤10 * dt * integrator.fsalfirst
    stage_limiter!(u, f, p, t + c1 * dt)
    f(k, u, p, t + c1 * dt)
    # u2
    @.. u‚ÇÇ = u + Œ≤21 * dt * k
    stage_limiter!(u‚ÇÇ, f, p, t + c2 * dt)
    f(k, u‚ÇÇ, p, t + c2 * dt)
    # u3
    @.. tmp = u‚ÇÇ + Œ≤32 * dt * k
    stage_limiter!(tmp, f, p, t + c3 * dt)
    f(k, tmp, p, t + c3 * dt)
    # u4
    @.. tmp = Œ±40 * uprev + Œ±41 * u + Œ±43 * tmp + Œ≤43 * dt * k
    stage_limiter!(tmp, f, p, t + c4 * dt)
    f(k, tmp, p, t + c4 * dt)
    # u5
    @.. tmp = tmp + Œ≤54 * dt * k
    stage_limiter!(tmp, f, p, t + c5 * dt)
    f(k, tmp, p, t + c5 * dt)
    # u
    @.. u = Œ±62 * u‚ÇÇ + Œ±65 * tmp + Œ≤65 * dt * k
    stage_limiter!(u, f, p, t + dt)
    step_limiter!(u, f, p, t + dt)
    integrator.destats.nf += 6
    f(k, u, p, t + dt)
end

#oop test
f = ODEFunction((u, p, t) -&gt; 1.01u,
    analytic = (u0, p, t) -&gt; u0 * exp(1.01t))
prob = ODEProblem(f, 1.01, (0.0, 1.0))
sol = solve(prob, RK_ALG(), dt = 0.1)

using Plots
plot(sol)
plot(sol, denseplot = false, plot_analytic = true)

using DiffEqDevTools
dts = (1 / 2) .^ (8:-1:1)
sim = test_convergence(dts, prob, RK_ALG())
sim.ùí™est[:final]
plot(sim)

# Example of a good one!
sim = test_convergence(dts, prob, BS3())
sim.ùí™est[:final]
plot(sim)

#iip test
f = ODEFunction((du, u, p, t) -&gt; (du .= 1.01 .* u),
    analytic = (u0, p, t) -&gt; u0 * exp(1.01t))
prob = ODEProblem(f, [1.01], (0.0, 1.0))
sol = solve(prob, RK_ALG(), dt = 0.1)

plot(sol)
plot(sol, denseplot = false, plot_analytic = true)

dts = (1 / 2) .^ (8:-1:1)
sim = test_convergence(dts, prob, RK_ALG())
sim.ùí™est[:final]
plot(sim)

# Example of a good one!
sim = test_convergence(dts, prob, BS3())
sim.ùí™est[:final]
plot(sim)</code></pre><h3 id="Adding-new-exponential-algorithms"><a class="docs-heading-anchor" href="#Adding-new-exponential-algorithms">Adding new exponential algorithms</a><a id="Adding-new-exponential-algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-new-exponential-algorithms" title="Permalink"></a></h3><p>The exponential algorithms follow the same recipe as the general algorithms, but there are automation utilities that make this easier. It is recommended that you refer to one of the model algorithms for reference:</p><ul><li>For traditional exponential Runge-Kutta type methods (that come with a corresponding Butcher table), refer to <code>ETDRK2</code>.</li><li>For adaptive exponential Rosenbrock type methods, refer to <code>Exprb32</code>.</li><li>For exponential propagation iterative Runge-Kutta methods (EPIRK), refer to <code>EPIRK5P1</code>.</li></ul><p>The first two classes support two modes of operation: operator caching and Krylov approximation. The <code>perform_step!</code> method in <code>perform_step/exponential_rk_perform_step.jl</code>, as a result, is split into two branches depending on whether <code>alg.krylov</code> is true. The caching branch utilizes precomputed operators, which are calculated by the <code>expRK_operators</code> method in <code>caches/linear_nonlinear_caches.jl</code>. Both <code>expRK_operators</code> and the <code>arnoldi</code>/<code>phiv</code> methods in <code>perform_step!</code> comes from the <a href="https://github.com/JuliaDiffEq/ExponentialUtilities.jl">ExponentialUtilities</a> package.</p><p>The EPIRK methods can only use Krylov approximation, and unlike the previous two they use the timestepping variant <code>phiv_timestep</code>. The timestepping method follows the convention of Neisen &amp; Wright, and can be toggled to use adaptation by <code>alg.adaptive_krylov</code>.</p><p>Although the exponential integrators (especially the in-place version) can seem complex, they share similar structures. The infrastructure for the existing exponential methods utilize the fact to reduce boilerplate code. In particular, the cache construction code in <code>caches/linear_nonlinear_caches.jl</code> and the <code>initialize!</code> method in <code>perform_step/exponential_rk_perform_step.jl</code> can be mostly automated and only <code>perform_step!</code> needs implementing.</p><p>Finally, to construct tests for the new exponential algorithm, append the new algorithm to the corresponding algorithm class in <code>test/linear_nonlinear_convergence_tests.jl</code> and <code>test/linear_nonlinear_krylov_tests.jl</code>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../adding_packages/">¬´ Adding a new package to the common interface</a><a class="docs-footer-nextpage" href="../defining_problems/">Developing A New Problem ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Wednesday 1 May 2024 05:57">Wednesday 1 May 2024</span>. Using Julia version 1.10.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
